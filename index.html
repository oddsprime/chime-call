<!DOCTYPE html>
<html lang="en">

<head>


  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chime Meeting</title>

  <!-- Relative paths for local files -->
  <!-- Debug Logger (must load first to hijack alerts) -->
  <script src="./debugLogger.js"></script>
  <!-- Chime Settings Utility (must load early for global access) -->
  <script src="./chimeSettingsUtility.js"></script>
  <!-- SocketHandler must be from external source (keep absolute) -->
  <script src="https://playground.codelinden.com/webSocket/SocketHandler.js"></script>
  <!-- Local files - relative paths -->
  <script src="./callFlowHandler.js"></script>
  <script src="./chimeHandler.js"></script>
  <script src="./newCamMic/camMicPermissionsUtility.js"></script>
  <script src="./newCamMic/camMicPermissionsHandler.js"></script>
    <script src="./chatHandler.js"></script>
    <script src="./reactionsHandler.js"></script>
    <script src="./giftAnimationHandler.js"></script>
    <script src="./coreChime.js"></script>

  <!-- Chime SDK - Original working version with blur/background support -->
  <script src="https://fs.codelinden.com/wp-content/plugins/fansocial/assets/chime-final-test/chime.min.js"></script>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="./style.css">
  <script src="./script.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- NEW COMPREHENSIVE VUE TEMPLATES - STYLES AND FONTS -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet" />
  
  <!-- Spinner animation for video sync loading -->
  <style>
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>

  <!-- Final Template Flow is driven by the ORIGINAL Vue instance (state/substate). -->
  <!-- Load template/component bundles for reuse, but do NOT mount a second Vue app. -->
  <script src="./vueComponents.js" defer></script>
  <script src="./vueComponentTemplates.js" defer></script>
  <script src="./vueComponentsMerch.js" defer></script>
  <script src="./vueComponentsSettings.js" defer></script>
  <script src="./vueComponentsCall.js" defer></script>
  <script src="./vueComponentsVideoCall.js" defer></script>
  <script src="./vueComponentsWaitingConnected.js" defer></script>
  <script src="./vueComponentCamMicPermissions.js" defer></script>
  <script src="./vueComponentChatSidebar.js" defer></script>

  <!-- Prosenjit Added those components -->
  <script src="components/vueComponentCallWaiting.js" defer></script>
  <script src="components/vueComponentMainCallVideo.js" defer></script> 
  <script src="components/vueComponentRemoteParticipant.js" defer></script>
  <script src="components/vueComponentBottomLeftInfo.js" defer></script>
  <script src="components/vueComponentBottomCenterControls.js" defer></script>
  <script src="components/vueComponentBottomRightControls.js" defer></script>
  <script src="components/vueComponentBottomControls.js" defer></script>
  <script src="components/vueComponentMobileHeader.js" defer></script>

  <!-- Harwinder imported components -->
  <script src="components/prejoin/vueComponentsConnecting.js" defer></script>
  <script src="components/prejoin/vueComponentsBackButton.js" defer></script>
  <script src="components/prejoin/vueComponentsCameraMicControls.js" defer></script>
  <script src="components/prejoin/vueComponentsJoinCallButton.js" defer></script>
  <script src="components/prejoin/vueComponentsAudioVideo.js" defer></script>
  <script src="components/prejoin/vueComponentsBackgroundsEffects.js" defer></script>
  <script src="components/prejoin/vueComponentsSettingsPanel.js" defer></script>
  <script src="components/prejoin/vueComponentsMobileJoinButton.js" defer></script>
  <script src="components/vueComponentTemplateChimeCalleeConnected.js" defer></script>

  <!-- Bottom Panel Buttons -->
  <script src="components/controlPanelbuttons/vueComponenChatButton.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponenReactButton.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponenSettingsButton.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponentTipButtons.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponenSettingsGear.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponenScreenSizeButton.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponentCameraButton.js" defer></script>
  <script src="components/controlPanelbuttons/vueComponentMicButton.js" defer></script>
  <script src="components/controlPanelbuttons/EndCallButton.js" defer></script>

  <!-- Calling Flow Components -->
  <script src="components/callingStep/IncomingCall.js"></script>
  <script src="components/LoadingSpinner.js"></script>
  <script src="components/callingStep/CallingCard.js"></script>
  <script src="components/callingStep/CallAccepetedCardCreator.js"></script>
  <script src="components/callingStep/CallPermissionCard.js"></script>
  <script src="components/callingStep/CallRejected.js"></script>
  <script src="components/callingStep/CallMissed.js"></script>
  <script src="components/callingStep/WaitingToJoin.js"></script>
  <script src="components/callingStep/waiting-avatar.js"></script>


  <style>

    * {
        scrollbar-width: none;
        -ms-overflow-style: none;  
        
      }

      *::-webkit-scrollbar {
        display: none;
      }


    video {
      width: 100%;
      height: 100% !important;
      max-width: 520px;
      background: #000;
      object-fit: cover;
      border-radius: 0 !important;
    }

    .slide-enter-active,
    .slide-leave-active {
      transition: transform 0.4s ease, opacity 0.4s ease;
    }
    .slide-enter-from,
    .slide-leave-to {
      transform: translateX(100%);
      opacity: 0;
    }
    .bg-gradient-pink{
      background: linear-gradient(90deg, rgba(255, 0, 102, 0.19) 0%, rgba(255, 0, 102, 0.13) 50%, rgba(255, 0, 102, 0.00) 100%);
    }
    .bg-yellow1{
        background: linear-gradient(0deg, rgba(0, 0, 0, 0.10) 0%, rgba(0, 0, 0, 0.10) 100%), linear-gradient(0deg, rgba(255, 205, 41, 0.75) -3.06%, rgba(255, 205, 41, 0.00) 117.35%);
      }


    /* Reaction animations */
    @keyframes reactionFadeInOut {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.6);
      }
      10% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
      20% {
        transform: translate(-50%, -50%) scale(1);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -60%) scale(0.8);
      }
    }

    .reaction-float {
      animation: reactionFadeInOut 2s ease-out forwards;
    }

    /* Gift animations */
    @keyframes giftFall {
      0% {
        top: -100px;
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        top: 100vh;
        opacity: 0;
      }
    }

    @keyframes giftRotate {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <!-- ===== Vue 3 bridge (passive listener) ===== -->
  <script src="https://unpkg.com/vue@3.4.31/dist/vue.global.prod.js"></script>

  <!-- Original Debug/Control Interface and Final Template Flow (same Vue instance) -->
  <div id="app">

      <!-- Chat Sidebar for Testing -->
      <!-- <chat-sidebar></chat-sidebar> -->

      <!-- Center reaction layer for emoji reactions -->
      <!-- <div id="reaction-layer" style="position: fixed; inset: 0; pointer-events: none; z-index: 3000;"></div> -->

      <div
      class="relative w-full h-screen overflow-hidden"
      :class="{
        // On desktop, show 400px panel when open
        'md:grid-cols-[1fr_400px]': ChimeCallSettings.callChatStatus,
        // On mobile, force 0 width since panel is absolute
        'grid-cols-[1fr_0px] md:grid-cols-[1fr_auto]': !ChimeCallSettings.callChatStatus || isMobile
      }">
      <div class="relative w-full h-screen" data-chime-templates>
        <div data-video-container class="w-full h-full absolute">
          <div id="reaction-layer" class="absolute w-full h-full inset-0 pointer-events-none z-[3000]"></div>
          <!-- ===============================
          CHIME TILE LAYOUT ‚Äî INTEGRATED
          =============================== -->
          <div v-show="['callee:joined','shared:inCall', 'caller:connectedJoined'].includes(state)" 
            id="chime-tile-layout" class="w-full h-full">

            <!-- Layout buttons -->
            <div class="max-w-6xl mx-auto p-3 hidden flex-wrap gap-2">
              <button data-layout="host_attendee"         class="px-3 py-1.5 rounded border bg-white hover:bg-slate-50">1 host / 1 attendee</button>
              <button data-layout="host_attendee_mainAtt" class="px-3 py-1.5 rounded border bg-white hover:bg-slate-50">1 host / 1 attendee (attendee main)</button>
              <button data-layout="host_3collabs"         class="px-3 py-1.5 rounded border bg-white hover:bg-slate-50">1 host / 3 collabs</button>
              <button data-layout="host_1collab"          class="px-3 py-1.5 rounded border bg-white hover:bg-slate-50">1 host / 1 collab</button>
              <button data-layout="host_2collabs"         class="px-3 py-1.5 rounded border bg-white hover:bg-slate-50">1 host / 2 collabs</button>
            </div>

            <div
                id="video-containers"
                class="relative overflow-hidden w-full h-full
                        grid grid-cols-12 grid-rows-2 gap-3"
                data-layout="host_attendee">
      
              <div id="host-container" data-name="host" data-container-type="host" data-attendee-id="" data-role="host" class="tile flex items-center justify-center rounded-xl text-white video-card">
                <!-- Video element will be added by UiMapTileToCard -->
              </div>
      
              <div id="collab1-container" data-name="collab1" data-container-type="collaborator" data-collab-index="1" data-attendee-id="" data-role="collaborator" class="tile flex items-center justify-center rounded-xl text-white video-card hidden">
                <!-- Video element will be added by UiMapTileToCard -->
              </div>
      
              <div id="collab2-container" data-name="collab2" data-container-type="collaborator" data-collab-index="2" data-attendee-id="" data-role="collaborator" class="tile flex items-center justify-center rounded-xl text-white video-card hidden">
                <!-- Video element will be added by UiMapTileToCard -->
              </div>
      
              <div id="collab3-container" data-name="collab3" data-container-type="collaborator" data-collab-index="3" data-attendee-id="" data-role="collaborator" class="tile flex items-center justify-center rounded-xl text-white video-card hidden">
                <!-- Video element will be added by UiMapTileToCard -->
              </div>
      
              <div id="attendee-container" data-name="attendee" data-container-type="attendee" data-attendee-id="" data-role="attendee" class="tile flex items-center justify-center rounded-xl text-white video-card]">
                <!-- Video element will be added by UiMapTileToCard -->
              </div>
            </div>
          </div>
          <!-- =============================== -->
        </div>
        <div data-template-container class="w-full h-full absolute ">
         
         
         
          <!-- üìû CALLER STATES -->
          <div v-if="state==='caller:startCall'">
            [Caller] Choose an option to start your call ‚Äî audio or video.
          </div>

          <div v-if="state === 'caller:callWaiting' || state === 'caller:callAccepted'" 
              class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex items-center justify-center">
            <span class="absolute top-0 left-0">[Caller] Calling‚Ä¶ waiting for the other person to answer. Displays user info, call type, and loading
              indicator.</span>
              <calling-card
                :show="state === 'caller:callWaiting' || state === 'caller:callAccepted'"
                :call-waiting-text="state === 'caller:callWaiting' ? 'Calling @jennyben' : ''"
                :call-accepted-text="state === 'caller:callAccepted' ? '@jennyben Accepted!' : ''"
                avatar-src="https://i.ibb.co.com/35W4r1KX/Vector-user.webp"
                @end-call="onEndCall"
                @toggle="toggleCamera"
                @toggle-mic="toggleMicrophone"
              ></calling-card>
            
          </div>

          <div v-if="state === 'caller:waitingForCamMicPermissions'"
              class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex items-center justify-center">
            <span class="absolute top-0 left-0">[Caller] Waiting for camera or microphone permissions‚Ä¶ please allow access to continue.</span>
            <call-permission-card
              :show="state === 'caller:waitingForCamMicPermissions'"
              @cancel="onCancelPermission"
              @settings="onOpenSettings"
              @toggle="toggleCamera"
              @toggle-mic="toggleMicrophone"
              @end-call="onEndCall"
            ></call-permission-card>

          </div>

          <div v-if="state==='caller:connectedJoined'">
            <!-- <waiting-to-join></waiting-to-join> -->
            [Caller] Connected and joined - waiting for Callee to join!
              <bottom-controls user-initials="UN" :toggle-camera="toggleCamera" :toggle-microphone="toggleMicrophone" 
                :toggle-chat="toggleChat" :chime-call-settings="ChimeCallSettings"></bottom-controls>
          </div>

          <div v-if="state==='caller:rejected'" class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex flex-col items-center justify-center">
            <!-- [Caller] ‚ùå You canceled the call. -->
             <span>Rejected</span>
             <call-rejected handle-text="Call rejected by @jennyben"></call-rejected>
          </div>

          <div v-if="state==='caller:declined'" class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex flex-col items-center justify-center">
            <!-- [Caller] üö´ The other person declined your call. -->
             <span>Declined</span>
             <call-rejected handle-text="Call rejected by @jennyben"></call-rejected>
          </div>

          <div v-if="state==='caller:terminated'" class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex flex-col items-center justify-center">
            <!-- [Caller] üîå The call has ended. -->
             <span> Terminated</span>
             <call-rejected></call-rejected>
          </div>


          <!-- üé• CALLEE STATES -->
          <div v-if="state==='callee:incomingAudioCall'">
            [Callee] üìû Incoming audio call ‚Äî displaying caller‚Äôs name, avatar, and call controls.
          </div>

          <div v-if="state === 'callee:incomingVideoCall'" 
              class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex items-center justify-center">
            <span class="absolute top-0 left-0">Callee] üé• Incoming video call ‚Äî showing caller‚Äôs details with options to accept or decline.</span>
            <incoming-call
              :show="state === 'callee:incomingVideoCall'"
              caller-name="SirStrawberry"
              caller-handle="@sammisjelly187"
              @accept="onAcceptCall"
              @decline="onDeclineCall"
              @options="onShowOptions"
            />
          </div>

          <div v-if="state==='callee:callAccepted'" class="relative w-full h-screen bg-[rgba(12,17,29,0.10)] backdrop-blur-[5px] flex items-center justify-center">
            <creator-call-acepted
              :show="state === 'callee:callAccepted'"
              handle-text="@jennyben Accepted!"
            ></creator-call-acepted>
          </div>

          <!-- <div v-if="state==='callee:waitingForCamMicPermissions'">
            [Callee] Waiting for camera or microphone permissions‚Ä¶ please allow access to continue.
          </div> -->


          <div v-if="state==='callee:connected'">
            <template-chime-callee-connected 
            :substate="substate" 
            :toggle-camera="toggleCamera"
              
            :toggle-microphone="toggleMicrophone"
              
            :chime-call-settings="ChimeCallSettings"></template-chime-callee-connected>
            [Callee] üîó Connecting to the call‚Ä¶

            zzzzz
          </div>

          <div v-if="state==='callee:joined'">
            <!-- [Callee] Joined with the callee. -->
          </div>

          <!-- <div v-if="state==='callee:rejected'">
            [Callee] ‚ùå You rejected the call.
          </div>

          <div v-if="state==='callee:declined'">
            [Callee] üö´ The caller declined your invitation.
          </div>

          <div v-if="state==='callee:terminated'">
            [Callee] üîå The call has ended.
          </div> -->


          <!-- ü§ù SHARED STATES (Both) -->
          <div v-if="state==='shared:networkIssue'">
            <!-- [Both] ‚ö†Ô∏è Network issue detected. Trying to reconnect‚Ä¶ -->
            <span>Terminated</span>
            <!-- <call-rejected></call-rejected> -->
          </div>

          <div v-if="state==='shared:reconnecting'">
            <!-- [Both] ‚ôªÔ∏è Reconnecting to the call‚Ä¶ please wait. -->
            <span>Terminated</span>
            <!-- <call-rejected></call-rejected> -->
          </div>

          <div v-if="state==='shared:disconnected'">
            <!-- [Both] ‚ö° Disconnected from the call. Attempting to restore connection. -->
            <span>Terminated</span>
            <!-- <call-rejected></call-rejected> -->
          </div>

          <div class="w-full h-full" v-if="state==='callee:joined' || state==='shared:inCall'">
            <!-- [Both] üéâ Call is active! Both participants are connected. -->

            <div class="w-full h-full" ref="callRoot" data-state="in-call" data-call-waiting="false"
              class="w-full h-full relative bg-cover bg-center bg-no-repeat background-image">
              <div class="w-full h-full flex">
                <div
                  class="_w-full flex-1 h-full inset-0 lg:p-0 flex items-center gap-2 mx-auto">
                  <section class="flex-1 flex flex-col gap-2 h-full relative">
                    <div class="absolute flex justify-center flex-col items-center gap-2 z-1 top-2 right-2">
                      <div class="flex lg:hidden h-8 w-8 justify-center items-center">
                        <img class="h-[22px] w-[22px]" src="https://new-stage.fansocial.app/wp-content/plugins/fansocial/dev/chimenew/assets/svgs/dots-horizontal.svg"/>
                      </div>
                      <div v-show="ChimeCallSettings.callMicStatus" class=""><img class="h-16 w-16" src="https://new-stage.fansocial.app/wp-content/plugins/fansocial/dev/chimenew/assets/mute-microphone.svg"/></div>
                    </div>

                    

                    <!-- Main Video Area -->
                    <div class="flex-1 relative rounded-card-xs bg-cover bg-center">
                      <!-- Call Waiting --->
                      <call-waiting v-if="isWaiting" user-initials="UN" :waiting-handle="'@' + userName"></call-waiting>
                      <!-- /Call Waiting --->

                      <!-- Main call Video -->
                      <!-- <main-call-video v-else></main-call-video> -->
                      <!-- Main call Video -->
                    </div>

                    <!-- Remote Participant Video (bottom Right) -->
                    <!-- <remote-participant></remote-participant> -->

                    <!-- Mobile header -->
                    <mobile-header meeting-time="November 5, 2025" user-name="jennyben" mode-text="Meeting with"
                      status-text="in 5 min"></mobile-header>

                    <div class="flex h-full absolute left-0 right-0">
                      <!-- Bottom Controls -->
                      <bottom-controls user-initials="UN" :toggle-camera="toggleCamera" :toggle-microphone="toggleMicrophone" 
                        :toggle-chat="toggleChat" :chime-call-settings="ChimeCallSettings"></bottom-controls>

                        <transition name="slide">
                          <div v-show="ChimeCallSettings.callChatStatus" 
                              class="absolute right-0 md:h-full
                               shadow-xl overflow-y-auto
                               w-full md:w-[400px] z-50">
                            <chat-sidebar :toggle-chat="toggleChat"></chat-sidebar>
                          </div>
                        </transition>
                    </div>
                  </section>
                </div>
              </div>
            </div>

          </div>
        </div>

      </div>
    </div>
    <!-- <chat-sidebar></chat-sidebar> -->
    

    


    <table>
      <tr>
        <td style="padding: 5px; border: 1px solid black">
          <strong>Settings</strong>
        </td>
        <td style="padding: 5px; border: 1px solid black">
          <div><strong @click="toggleCamera">Camera:</strong> {{ ChimeCallSettings.callCamStatus ? 'On' : 'Off' }}</div>
          <div><strong>Microphone:</strong> {{ ChimeCallSettings.callMicStatus ? 'On' : 'Off' }}</div>
          <div><strong>Chat:</strong> {{ ChimeCallSettings.callChatStatus ? 'On' : 'Off' }}</div>
          <div><strong>Callee Image URL:</strong> {{ ChimeCallSettings.userAvatarUrl || 'No image set' }}</div>
        </td>
      </tr>
    </table>










  <!-- Call Data Sentence Display -->
      <div v-if="callDataSentence" id="call-data-sentence" class="mt-4 p-4 border border-orange-400 rounded" style="max-width: 1200px; margin-left: auto; margin-right: auto; background-color: #FFA500;">
        <p class="text-sm text-white font-medium" style="line-height: 1.8;" v-html="callDataSentence"></p>
      </div>

   
      <!-- CamMic Permissions Container (Always Visible for Testing) -->


 









  </div><!-- .app --><span>test</span>



 <script>
    // Mock Call Data - Single Source of Truth
    window.mockCallData = {
      currentUser: {
        userId: "444",
        username: "test_user_444",
        displayName: "Test User 444",
        avatar: "https://picsum.photos/seed/user444/100/100",
        initials: "TU",
        isCreator: false,  // true if creator, false if fan
        isFan: true        // true if fan, false if creator
      },
      targetUser: {
        userId: "666", 
        username: "test_user_666",
        displayName: "Test User 666",
        avatar: "https://picsum.photos/seed/user666/100/100",
        initials: "TU",
        isCreator: true,   // true if creator, false if fan
        isFan: false       // true if fan, false if creator
      },
      // Will be populated dynamically
      callType: null, // "INSTANT_ONE_ON_ONE" or "GROUP_ONE_ON_ONE"
      mediaType: null, // "audio" or "video"
      currentUserRole: null, // "host", "attendee", "collaborator"
      currentUserSide: null, // "caller" or "callee"
      isInGrace: false
    };
    
    // Utility functions to check user types
    window.mockCallData.isCurrentUserCreator = function() {
      return this.currentUser && this.currentUser.isCreator === true;
    };
    
    window.mockCallData.isCurrentUserFan = function() {
      return this.currentUser && this.currentUser.isFan === true;
    };
    
    window.mockCallData.isTargetUserCreator = function() {
      return this.targetUser && this.targetUser.isCreator === true;
    };
    
    window.mockCallData.isTargetUserFan = function() {
      return this.targetUser && this.targetUser.isFan === true;
    };
    
    console.log('[mockCallData] Initialized:', window.mockCallData);
    console.log('[mockCallData] Current user is creator:', window.mockCallData.isCurrentUserCreator());
    console.log('[mockCallData] Target user is creator:', window.mockCallData.isTargetUserCreator());
  </script>






  <div id="call-controls">
    <h2 style="font-size: 2em">call Controls</h2>
    <table style="width: 100%; border-collapse: collapse" border="1">
      <tbody>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Initiate Call</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <button id="btnStartAudioCall" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">
              üé§ Start Audio Instant Call
            </button>
            <button id="btnStartVideoCall" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">
              üìπ Start Video Instant Call
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Respond to Call</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <button id="btnAccept" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">
              Accept
            </button>
            <select id="rejectReason" style="
                    border: 1px solid #6c757d;
                    padding: 6px 12px;
                    border-radius: 6px;
                    margin: 0 5px;
                    cursor: pointer;
                  ">
              <option value="busy">Busy</option>
              <option value="not_available">Not available</option>
              <option value="in_another_call">In another call</option>
              <option value="spam">Spam</option>
            </select>
            <button id="btnReject" style="
                    border: 1px solid #dc3545;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #dc3545;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#bb2d3b'" onmouseout="this.style.background='#dc3545'">
              Reject
            </button>
            <button id="btnCancelCall" style="
                    border: 1px solid #6c757d;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #6c757d;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#5c636a'" onmouseout="this.style.background='#6c757d'">
              Cancel
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Media Controls</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <a id="link-video-on" href="#" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    display: inline-block;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">Video On</a>
            <a id="link-video-off" href="#" style="
                    border: 1px solid #6c757d;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #6c757d;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    display: inline-block;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#5c636a'" onmouseout="this.style.background='#6c757d'">Video Off</a>
            <a id="link-audio-on" href="#" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    display: inline-block;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">Audio On</a>
            <a id="link-audio-off" href="#" style="
                    border: 1px solid #6c757d;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #6c757d;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    display: inline-block;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#5c636a'" onmouseout="this.style.background='#6c757d'">Audio Off</a>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Video Effects</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <label>Blur:</label>
            <select id="blurLevelSelect">
              <option value="off">Off</option>
              <option value="low">Low</option>
              <option value="medium">Medium</option>
              <option value="high">High</option>
            </select>
            <label>Background:</label>
            <select id="backgroundSelect">
              <option value="">None</option>
              <option value="https://fs.codelinden.com/wp-content/uploads/2024/bg1.jpg">
                Beach
              </option>
              <option value="https://fs.codelinden.com/wp-content/uploads/2024/bg2.jpg">
                Office
              </option>
              <option value="https://fs.codelinden.com/wp-content/uploads/2024/bg3.jpg">
                Nature
              </option>
              <option value="https://fs.codelinden.com/wp-content/uploads/2024/bg4.jpg">
                City
              </option>
            </select>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Data Actions</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <a id="link-react" href="#" data-flag="reaction" data-payload='{"emoji":"‚ù§Ô∏è","intensity":1,"target":"all"}'
              style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">React</a>
            <a id="link-send-gift" href="#" data-flag="gift" data-payload='{"giftId":"rose","qty":1,"target":"all"}'
              style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">Send Gift</a>
            <a id="link-send-chat" href="#" data-flag="chat" data-payload='{"text":"Hi there!","target":"all"}' style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">Send Chat</a>
            <a id="link-send-chat-promo" href="#" data-flag="chatPromo"
              data-payload='{"promoId":"WELCOME10","target":"all"}' style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">Send Promo</a>
            <a id="link-tip" href="#" data-flag="tip" data-payload='{"amount":10,"currency":"TOK","target":"all"}'
              style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">Tip</a>
          </td>
        </tr>
      </tbody>
    </table>
  </div>


  <div id="debug-container">
    <h2 style="font-size: 2em">debug Controls</h2>
    <table style="width: 100%; border-collapse: collapse" border="1">
      <tbody>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Call Type</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <select id="callType">
              <option value="INSTANT_ONE_ON_ONE">Instant one on one</option>
              <option value="SCHEDULED_ONE_ON_ONE">
                Schedule one on one
              </option>
              <option value="GROUP_ONE_ON_ONE">Group one on one</option>
            </select>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Role</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <select id="role">
              <option value="host" selected>Host</option>
              <option value="collaborator">Collaborator</option>
              <option value="attendee">Attendee</option>
            </select>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>User IDs</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <input id="currentUserId" placeholder="Your ID" autocomplete="off" />
            <input id="targetUserId" placeholder="Target User ID" autocomplete="off" />
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Socket</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <button id="btnLoginRegister" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">
              Register Logged In (Connect Socket)
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>√∞≈∏"‚Äπ Mock User Data</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black; font-family: monospace; font-size: 11px;">
            <div id="mock-data-display" style="white-space: pre-wrap;"></div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>√¢¬è¬≥ Grace Period</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Status:</strong> <span id="grace-status">FALSE</span><br><br>
            <button id="btn-grace-start" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">Start Grace Period</button>
            <button id="btn-grace-resume" style="
                    border: 1px solid #0d6efd;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #0d6efd;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#0b5ed7'" onmouseout="this.style.background='#0d6efd'">Resume from Grace</button>
            <button id="btn-grace-end-fail" style="
                    border: 1px solid #dc3545;
                    padding: 6px 12px;
                    text-decoration: none;
                    background: #dc3545;
                    color: #fff;
                    margin: 0 5px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: 500;
                    transition: background-color 0.2s;
                  " onmouseover="this.style.background='#bb2d3b'" onmouseout="this.style.background='#dc3545'">End Grace (Fail)</button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>√∞≈∏‚Äú≈† Current Call State</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div style="font-size: 12px;">
              <strong>Call Type:</strong> <span id="debug-call-type">-</span><br>
              <strong>Media Type:</strong> <span id="debug-media-type">-</span><br>
              <strong>Your Role:</strong> <span id="debug-your-role">-</span><br>
              <strong>Your Side:</strong> <span id="debug-your-side">-</span><br>
              <strong>Grace Period:</strong> <span id="debug-grace">FALSE</span><br><br>
              
              <strong>Your Details:</strong><br>
              <span id="debug-current-user" style="margin-left: 10px;">-</span><br><br>
              
              <strong>Other User Details:</strong><br>
              <span id="debug-target-user" style="margin-left: 10px;">-</span>
            </div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>√∞≈∏"‚Äò Token Updates (Rehan)</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <!-- Rehan will add token update buttons here -->
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>callSettings</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div style="font-size: 12px;">
              <strong>callCamStatus:</strong> <span id="debug-call-cam-status">-</span><br>
              <strong>callMicStatus:</strong> <span id="debug-call-mic-status">-</span>
            </div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Cam/Mic Global Settings</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div style="font-size: 12px;">
              <strong>Camera:</strong> <span id="debug-global-cam-status">OFF</span><br>
              <strong>Microphone:</strong> <span id="debug-global-mic-status">OFF</span>
            </div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Chime Call State</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div id="ui-status" style="display: inline-block">
              <strong>Status:</strong> Idle√¢‚Ç¨¬¶
            </div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>UI State</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div style="margin-top: 8px">
              current √¢‚Ä†' state:
              <b id="debug-ui-state">(none)</b> /
              substate: <b id="debug-ui-substate">(none)</b>
            </div>

            <!-- √∞≈∏"¬π History log -->
            <div id="ui-history"
              style="margin-top: 10px; max-height: 180px; overflow-y: auto; font-family: monospace; font-size: 13px;">
            </div>

            <script>
              // Update state/substate display elements
              function updateUIStateDisplay(state, substate) {
                const stateEl = document.getElementById('debug-ui-state');
                const substateEl = document.getElementById('debug-ui-substate');
                if (stateEl) stateEl.textContent = state || '(none)';
                if (substateEl) substateEl.textContent = substate || '(none)';
              }

              document.addEventListener("chime-ui::state", (e) => {
                const d = e.detail;
                const ts = new Date(d.ts).toLocaleTimeString();
                console.log("[UI EVENT] chime-ui::state received √¢‚Ä†'", d);

                // Update state/substate display (outside Vue)
                updateUIStateDisplay(d.state, d.substate);

                // update live state display if using Vue/reactivity
                if (window.vueApp && window.vueApp.state !== undefined) {
                  // Only update Vue state if it's actually changing (prevent UI flicker)
                  if (window.vueApp.state !== d.state) {
                    console.log('[UI EVENT] State changed:', window.vueApp.state, '->', d.state);
                    window.vueApp.state = d.state;
                  } else {
                    console.log('[UI EVENT] State unchanged (no UI shift):', d.state);
                  }
                  
                  // Always update substate (for tracking)
                  window.vueApp.substate = d.substate;
                }
                
                // Update global settings with current state and role
                if (window.settings) {
                  window.settings.currentState = d.state || '';
                  window.settings.currentSubstate = d.substate || '';
                  // Extract role from state (e.g., 'caller:callWaiting' -> 'caller')
                  const role = d.state ? d.state.split(':')[0] : '';
                  window.settings.currentRole = (role === 'caller' || role === 'callee') ? role : '';
                  console.log('[UI EVENT] Global settings updated:', {
                    currentState: window.settings.currentState,
                    currentRole: window.settings.currentRole,
                    currentSubstate: window.settings.currentSubstate
                  });
                }

                // append history line
                const history = document.getElementById("ui-history");
                if (history) {
                  const p = document.createElement("p");
                  p.textContent = `[${ts}] ${d.state} / ${d.substate || 'none'} (caller: ${d.callerId || '-'}, callee: ${d.calleeId || '-'})`;
                  history.appendChild(p);
                  // keep scroll pinned to bottom
                  history.scrollTop = history.scrollHeight;
                }
              });

              // Listen for debug control events for cam/mic global settings
              document.addEventListener("debugControls:camOn", () => {
                const el = document.getElementById('debug-global-cam-status');
                if (el) el.textContent = 'ON';
              });

              document.addEventListener("debugControls:camOff", () => {
                const el = document.getElementById('debug-global-cam-status');
                if (el) el.textContent = 'OFF';
              });

              document.addEventListener("debugControls:micOn", () => {
                const el = document.getElementById('debug-global-mic-status');
                if (el) el.textContent = 'ON';
              });

              document.addEventListener("debugControls:micOff", () => {
                const el = document.getElementById('debug-global-mic-status');
                if (el) el.textContent = 'OFF';
              });

              // Initialize display on load
              setTimeout(() => {
                if (window.settings) {
                  if (window.settings.callCamStatus) {
                    document.dispatchEvent(new CustomEvent('debugControls:camOn'));
                  } else {
                    document.dispatchEvent(new CustomEvent('debugControls:camOff'));
                  }
                  
                  if (window.settings.callMicStatus) {
                    document.dispatchEvent(new CustomEvent('debugControls:micOn'));
                  } else {
                    document.dispatchEvent(new CustomEvent('debugControls:micOff'));
                  }
                }
              }, 500);
            </script>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Vue State Shifter</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <label>state:</label>
            <select id="stateSelect" onchange="CallHandler.dipatchUI(this.value)">
              <option value="">(none)</option>

              <!-- Caller -->
              <option value="caller:startCall">caller:startCall</option>
              <option value="caller:callWaiting">caller:callWaiting</option>
              <option value="caller:callAccepted">caller:callAccepted</option>
              <option value="caller:waitingForCamMicPermissions">caller:waitingForCamMicPermissions</option>
              <option value="caller:connectedJoined">caller:connectedJoined</option>
              <option value="caller:rejected">caller:rejected</option>
              <option value="caller:declined">caller:declined</option>
              <option value="caller:terminated">caller:terminated</option>

              <!-- Callee -->
              <option value="callee:incomingAudioCall">callee:incomingAudioCall</option>
              <option value="callee:incomingVideoCall">callee:incomingVideoCall</option>
              <option value="callee:callAccepted">callee:callAccepted</option>
              <option value="callee:waitingForCamMicPermissions">callee:waitingForCamMicPermissions</option>
              <option value="callee:connected">callee:connected</option>
              <option value="callee:joined">callee:joined</option>
              <option value="callee:rejected">callee:rejected</option>
              <option value="callee:declined">callee:declined</option>
              <option value="callee:terminated">callee:terminated</option>

              <!-- Shared -->
              <option value="shared:networkIssue">shared:networkIssue</option>
              <option value="shared:reconnecting">shared:reconnecting</option>
              <option value="shared:disconnected">shared:disconnected</option>
              <option value="shared:inCall">shared:inCall</option>
            </select>

            <label>substate:</label>
            <select title="Substates for testing to integrate later">
              <option value="">(none)</option>
              <option value="test1">test1</option>
              <option value="test2">test2</option>
              <option value="test3">test3</option>
              <option value="test3">test4</option>
            </select>

            <div><span>State history</span><span id="history"></span></div>



          </td>
        </tr>
        
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Camera Status</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <strong data-cam-mic-element="status-camera">prompt</strong>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Microphone Status</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <strong data-cam-mic-element="status-microphone">prompt</strong>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Camera Permission Needed</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div data-cam-mic-element="need-camera" hidden>
              √∞≈∏‚Äú¬∑ Camera permission needed
            </div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Microphone Permission Needed</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <div data-cam-mic-element="need-microphone" hidden>
              √∞≈∏≈Ω¬§ Microphone permission needed
            </div>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Cam/Mic Actions</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <button data-cam-mic-action="check-permissions" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Check Permissions
            </button>
            <button data-cam-mic-action="request-camera-microphone" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Request Both
            </button>
            <button data-cam-mic-action="stop-streams" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Stop Streams
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Meeting Actions</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <a id="link-join-meeting" href="#" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">Join Meeting</a>
            <a id="link-start" href="#" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">Start</a>
            <a id="link-end" href="#" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">End</a>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>ChimeDebugLog</strong>
          </td>
          <td style="
                  padding: 5px;
                  border: 1px solid black;
                  background: #111;
                  color: #0f0;
                  font-family: monospace;
                  font-size: 12px;
                ">
            <div id="debug-log-output" style="height: 200px; overflow-y: scroll"></div>
          </td>
        </tr>
        <!-- Test Chat Controls Row -->
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>√∞≈∏¬ß¬™ Test Chat</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <button id="debug-show-chat">Show Chat</button>
            <br><br>
            <label><strong>As You:</strong></label><br>
            <input id="debug-chat-input-self" type="text" placeholder="Type message..." style="width: 300px; padding: 5px; margin: 5px 0;">
            <button id="debug-send-self">Send</button>
            <br><br>
            <label><strong>As Other:</strong></label><br>
            <input id="debug-chat-input-other" type="text" placeholder="Type message..." style="width: 300px; padding: 5px; margin: 5px 0;">
            <button id="debug-send-other">Send</button>
            <br><br>
            <button id="debug-send-emoji">Emoji √¢¬ù¬§√Ø¬∏¬è</button>
            <button id="debug-send-media">Media Card</button>
            <button id="debug-send-merch">Product Card</button>
            <button id="debug-send-subscription">Subscription Card</button>
            <button id="debug-send-gift">Gift √∞≈∏≈Ω¬Å</button>
            <button id="debug-send-reaction">Reaction √∞≈∏Àú‚Ç¨</button>
          </td>
        </tr>
      </tbody>
    </table>
  </div>

  <div id="host-controls">
    <h2 style="font-size: 2em">Host Controls</h2>
    <table style="width: 100%; border-collapse: collapse" border="1">
      <tbody>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Bulk Actions</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <button id="btn-mute-all" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Mute All
            </button>
            <button id="btn-unmute-all" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Unmute All
            </button>
            <button id="btn-end-for-all" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              End Call for All
            </button>
            <button id="btn-set-max-attendees" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Set Max Attendees
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Assign Host</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <select id="select-host-candidate">
              <option value="">Select participant√¢‚Ç¨¬¶</option>
            </select>
            <button id="btn-assign-host" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Assign
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Manage Collaborators</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <input id="input-collabs" placeholder="uid1, uid2, uid3, uid4" />
            <button id="btn-save-collabs" style="
                    border: 1px solid #ccc;
                    padding: 2px 6px;
                    text-decoration: none;
                    background: #f0f0f0;
                    color: #333;
                    margin: 0 5px;
                  ">
              Save
            </button>
          </td>
        </tr>
        <tr>
          <td style="padding: 5px; border: 1px solid black">
            <strong>Meeting Info</strong>
          </td>
          <td style="padding: 5px; border: 1px solid black">
            <span>Meeting: <code id="label-meeting-id">-</code></span> √¢‚Ç¨¬¢
            <span>Type: <code id="label-meeting-type">-</code></span> √¢‚Ç¨¬¢
            <span>Participants:
              <code id="label-participant-count">0</code>/<code id="label-max-participants">-</code></span>
          </td>
        </tr>
      </tbody>
    </table>
  </div>





  <script>
    // ============================================================
    // GLOBAL STATE DISPATCH THROTTLE
    // Intercepts ALL chime-ui::state events to prevent rapid duplicates
    // ============================================================
    (function setupGlobalStateThrottle() {
      let lastState = null;
      let lastSubstate = null;
      let lastDispatchTime = 0;
      const throttleMs = 50;
      
      // Intercept document.dispatchEvent for chime-ui::state
      const originalDispatch = document.dispatchEvent.bind(document);
      document.dispatchEvent = function(event) {
        if (event.type === 'chime-ui::state' && event.detail) {
          const { state, substate } = event.detail;
          const now = Date.now();
          const timeSince = now - lastDispatchTime;
          
          // Check for duplicate within throttle window
          if (state === lastState && substate === lastSubstate && timeSince < throttleMs) {
            console.log(`[GlobalThrottle] √¢¬è¬≠√Ø¬∏¬è BLOCKED duplicate: ${state} / ${substate} (${timeSince}ms ago)`);
            return true; // Pretend it was dispatched
          }
          
          // Update tracking
          lastState = state;
          lastSubstate = substate;
          lastDispatchTime = now;
        }
        
        // Call original dispatch
        return originalDispatch(event);
      };
      
      console.log('[GlobalThrottle] √¢≈ì‚Ä¶ Global state throttle installed');
    })();
    
    (function bootstrapVue() {
      function startApp() {
        const { ref, onMounted, onBeforeUnmount } = Vue;

        const comps = {};
        if (window.VueComponents?.WaitingConnected) {
          comps.WaitingConnected = window.VueComponents.WaitingConnected;
        }
        if (window.VueComponents?.TemplateCamMicPermissions) {
          comps.TemplateCamMicPermissions = window.VueComponents.TemplateCamMicPermissions;
        }
        // Harwinder registered components
        if (window.VueComponents?.TemplateCamMicPermissions) {
          comps.TemplateCamMicPermissions = window.VueComponents.TemplateCamMicPermissions;
        }
        if (window.VueComponents?.ConnectingSection) {
          comps.ConnectingSection = window.VueComponents.ConnectingSection;
        }
        if (window.VueComponents?.BackButton) {
          comps.BackButton = window.VueComponents.BackButton;
        }
        if (window.VueComponents?.CameraMicControls) {
          comps.CameraMicControls = window.VueComponents.CameraMicControls;
        }
        if (window.VueComponents?.JoinCallButton) {
          comps.JoinCallButton = window.VueComponents.JoinCallButton;
        }
        if (window.VueComponents?.SettingsPanel) {
          comps.SettingsPanel = window.VueComponents.SettingsPanel;
        }
        if (window.VueComponents?.PrejoinMobileHeader) {
          comps.PrejoinMobileHeader = window.VueComponents.PrejoinMobileHeader;
        }
        if (window.VueComponents?.MobileJoinButton) {
          comps.MobileJoinButton = window.VueComponents.MobileJoinButton;
        }
        if (window.VueComponents?.TemplateChimeCalleeConnected) {
          comps.TemplateChimeCalleeConnected = window.VueComponents.TemplateChimeCalleeConnected;
        }
        if (window.VueComponents?.ChatSidebar) {
          comps.ChatSidebar = window.VueComponents.ChatSidebar;
        }

        try {
          // Initialize CamMic handler before creating Vue app
          console.log('[index.html] Initializing CamMicPermissionsHandler...');
          window.dispatchEvent(new CustomEvent('CamMic:Init'));
          console.log('[index.html] ‚úÖ CamMic:Init event dispatched');

          const app = Vue.createApp({
            components: comps,
            setup() {
              const state = ref('');
              const substate = ref('');
              const stateSel = ref('');
              const subSel = ref('');

              // Reactive settings object
              const ChimeCallSettings = Vue.reactive({
                callCamStatus: false,
                callMicStatus: false,
                callChatStatus: false, // Chat sidebar visibility state
                userAvatarUrl: '',
                userType:'',
                currentState: '', // Full state (e.g., 'caller:callWaiting', 'callee:incomingVideoCall')
                currentRole: '', // Extracted role ('caller' or 'callee')
                currentSubstate: '', // Substate if any
              });

              window.settings = ChimeCallSettings; 

              // √¢≈ì‚Ä¶ Vue click handlers
              // function to toggle camera - EXACT FLOW FROM DEMO
              function toggleCamera() {
                const newState = !ChimeCallSettings.callCamStatus;
                ChimeCallSettings.callCamStatus = newState;
                
                // Dispatch debug control event for camera status
                document.dispatchEvent(new CustomEvent(newState ? 'debugControls:camOn' : 'debugControls:camOff'));
                
                console.log(`[Vue] Camera toggled √¢‚Ä†' ${newState ? 'ON' : 'OFF'}, current state: ${state.value}`);
                
                // If turning ON and in caller:callWaiting or caller:callAccepted, use CamMic with proper state management
                if (newState && (state.value === 'caller:callWaiting' || state.value === 'caller:callAccepted')) {
                  console.log(`[Vue] [CamMic] Starting CamMic orchestration flow...`);
                  
                  const mediaType = window.mockCallData?.mediaType || 'video';
                  const isVideoCall = mediaType === 'video';
                  const returnState = state.value;
                  
                  // Listen for UI events from CamMic handler
                  const onShowWaiting = (ev) => {
                    console.log('[Vue] [CamMic] CamMic:UI:ShowWaiting - transitioning to caller:waitingForCamMicPermissions');
                    document.dispatchEvent(new CustomEvent('chime-ui::state', {
                      detail: {
                        state: 'caller:waitingForCamMicPermissions',
                        substate: 'none',
                        ts: Date.now(),
                      }
                    }));
                  };
                  
                  const onPermissionsResolved = (ev) => {
                    console.log('[Vue] [CamMic] CamMic:UI:PermissionsResolved - returning to', returnState);
                    document.dispatchEvent(new CustomEvent('chime-ui::state', {
                      detail: {
                        state: returnState,
                        substate: 'none',
                        ts: Date.now(),
                      }
                    }));
                  };
                  
                  // Register listeners BEFORE dispatching
                  window.addEventListener('CamMic:UI:ShowWaiting', onShowWaiting);
                  window.addEventListener('CamMic:UI:PermissionsResolved', onPermissionsResolved);
                  
                  // Cleanup on completion
                  const onOrchestrationComplete = (ev) => {
                    window.removeEventListener('CamMic:UI:ShowWaiting', onShowWaiting);
                    window.removeEventListener('CamMic:UI:PermissionsResolved', onPermissionsResolved);
                    window.removeEventListener('CamMic:Orchestrate:Complete', onOrchestrationComplete);
                  };
                  window.addEventListener('CamMic:Orchestrate:Complete', onOrchestrationComplete);
                  
                  // Dispatch orchestration
                  if (isVideoCall) {
                    console.log('[Vue] [CamMic] Dispatching CamMic:Orchestrate:Both');
                    window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both'));
                  } else {
                    console.log('[Vue] [CamMic] Dispatching CamMic:Orchestrate:Microphone');
                    window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Microphone'));
                  }
                  
                  return;
                }
                
                if (typeof chimeHandler !== 'undefined' && chimeHandler.handleVideoToggle) {
                  chimeHandler.handleVideoToggle(newState);
                }
              }

              // function to toggle microphone
              function toggleMicrophone() {
                const newState = !ChimeCallSettings.callMicStatus;
                ChimeCallSettings.callMicStatus = newState;
                
                // Dispatch debug control event for microphone status
                document.dispatchEvent(new CustomEvent(newState ? 'debugControls:micOn' : 'debugControls:micOff'));
                
                if (typeof chimeHandler !== 'undefined' && chimeHandler.handleAudioToggle) {
                  chimeHandler.handleAudioToggle(newState);
                }
                console.log(`[Vue] Microphone toggled √¢‚Ä†' ${newState ? 'ON' : 'OFF'}`);
              }

              // function to toggle chat sidebar
              function toggleChat() {
                // Toggle reactive state - Vue will handle mounting/unmounting and slide animation
                const newState = !ChimeCallSettings.callChatStatus;
                ChimeCallSettings.callChatStatus = newState;
                console.log(`[Vue] Chat toggled ‚Üí ${newState ? 'VISIBLE' : 'HIDDEN'}`);
                
                // If opening chat panel, initialize chatHandler after Vue mounts the component
                if (newState) {
                  // Wait for Vue to mount the component, then initialize chatHandler
                  setTimeout(() => {
                    if (typeof window.initChatHandlerManually === 'function') {
                      console.log('[Vue] Chat panel opened - initializing chatHandler');
                      window.initChatHandlerManually();
                    } else {
                      console.warn('[Vue] initChatHandlerManually not available');
                    }
                  }, 100); // Small delay to ensure Vue has mounted the component
                }
              }

              // const applyUiState = (st, sub) => {
              //   alert('state changed: ' + st);
              //   state.value = st;
              //   substate.value = sub;
              //   document.dispatchEvent(
              //     new CustomEvent('chime-ui::state', {
              //       detail: { state: st, substate: sub || '', ts: Date.now() },
              //     }),
              //   );
              // };

              // Prosenjit: NEW: refs for the attribute-based visibility
              const callRoot = ref(null);       // bind this to the element that has data-call-waiting
              const isWaiting = ref(false);      // true -> show "waiting layout", false -> show "video call"
              let attrObserver = null;

              // Call data sentence - reactive with ref
              const callDataSentence = Vue.ref('');
              
              // Watch mockCallData and update sentence
              const updateCallDataSentence = () => {
                if (typeof window === 'undefined' || !window.mockCallData) {
                  callDataSentence.value = '';
                  return;
                }
                
                const data = window.mockCallData;
                if (!data.callType || !data.currentUser || !data.targetUser) {
                  callDataSentence.value = '';
                  return;
                }

                const role = data.currentUserRole || '-';
                const callType = data.callType ? data.callType.replace(/_/g, ' ').toLowerCase() : '-';
                const mediaType = data.mediaType || 'video';
                const side = data.currentUserSide === 'caller' ? 'called' : 'received a call';
                
                const userType = data.currentUser.isCreator ? 'Creator' : 'Fan';
                const otherUserType = data.targetUser.isCreator ? 'Creator' : 'Fan';

                ChimeCallSettings.userType = userType;

                const yourDetails = [
                  `User ID: ${data.currentUser.userId}`,
                  `Username: @${data.currentUser.username}`,
                  `Display Name: ${data.currentUser.displayName}`,
                  data.currentUser.avatar ? `Avatar: ${data.currentUser.avatar}` : null,
                  `Initials: ${data.currentUser.initials}`,
                  `Type: ${userType}`
                ].filter(Boolean).join(', ');

                const otherDetails = [
                  `User ID: ${data.targetUser.userId}`,
                  `Username: @${data.targetUser.username}`,
                  `Display Name: ${data.targetUser.displayName}`,
                  data.targetUser.avatar ? `Avatar: ${data.targetUser.avatar}` : null,
                  `Initials: ${data.targetUser.initials}`,
                  `Type: ${otherUserType}`
                ].filter(Boolean).join(', ');

                callDataSentence.value = `You are a <strong>${userType} (${role})</strong> in a <strong>${callType}</strong> call (${mediaType}). You have <strong>${side}</strong>. Your details: ${yourDetails}. Other user details: ${otherDetails}.`;
              };
              
              // Helper functions for Vue templates
              const getMediaType = () => {
                if (typeof window === 'undefined' || !window.mockCallData) return 'video';
                return window.mockCallData.mediaType || 'video';
              };
              
              const getTargetUser = () => {
                if (typeof window === 'undefined' || !window.mockCallData || !window.mockCallData.targetUser) return null;
                return window.mockCallData.targetUser;
              };
              
              // Update on mount and periodically
              updateCallDataSentence();
              setInterval(updateCallDataSentence, 500);

              const handleUiStateEvent = (e) => {
                const d = e.detail;
                if (d && d.state) {
                  state.value = d.state;
                  substate.value = d.substate || '';
                }
              };

              onMounted(() => {
                document.addEventListener('chime-ui::state', handleUiStateEvent);

                // Prosenjit: Read initial attribute
                const el = callRoot.value || document.querySelector('[data-call-waiting]');
                if (!el) {
                  console.warn('No element found with data-call-waiting');
                } else {
                  isWaiting.value = el.getAttribute('data-call-waiting') === 'true';

                  // Keep in sync with live attribute changes
                  attrObserver = new MutationObserver((mutations) => {
                    for (const m of mutations) {
                      if (m.type === 'attributes' && m.attributeName === 'data-call-waiting') {
                        isWaiting.value = el.getAttribute('data-call-waiting') === 'true';
                      }
                    }
                  });
                  attrObserver.observe(el, { attributes: true, attributeFilter: ['data-call-waiting'] });
                }

                const logUiClick = (action) => {
                  if (typeof DebugLogger !== 'undefined' && DebugLogger?.addLog) {
                    DebugLogger.addLog(state.value || 'ready', 'NOTICE', 'UI', `${action} clicked`);
                  }
                };

                const buttons = [
                  { id: 'link-video-on', label: 'Video On' },
                  { id: 'link-video-off', label: 'Video Off' },
                  { id: 'link-audio-on', label: 'Audio On' },
                  { id: 'link-audio-off', label: 'Audio Off' },
                  { id: 'link-react', label: 'React' },
                  { id: 'link-send-gift', label: 'Send Gift' },
                  { id: 'link-send-chat', label: 'Send Chat' },
                  { id: 'link-send-chat-promo', label: 'Send Promo' },
                  { id: 'link-tip', label: 'Tip' },
                  { id: 'link-join-meeting', label: 'Join Meeting' },
                  { id: 'link-start', label: 'Start' },
                  { id: 'link-end', label: 'End' },
                ];

                buttons.forEach(({ id, label }) => {
                  const el = document.getElementById(id);
                  if (el) {
                    el.addEventListener('click', () => logUiClick(label));
                  }
                });
              });

              onBeforeUnmount(() => {
                document.removeEventListener('chime-ui::state', handleUiStateEvent);
              });

              return {
                state,
                substate,
                stateSel,
                subSel,
                callDataSentence,
                callRoot,   // expose ref
                isWaiting,  // used by v-if/v-else
                ChimeCallSettings,
                toggleCamera,
                toggleMicrophone,
                toggleChat,
                getMediaType,
                getTargetUser,
              };
            },
          });

          //Prosenjit: Register your two components here
          if (typeof registerCallWaiting === 'function') registerCallWaiting(app);
          if (typeof registerMainCallVideo === 'function') registerMainCallVideo(app);
          if (typeof registerRemoteParticipant === 'function') registerRemoteParticipant(app);
          if (typeof registerBottomLeftInfo === 'function') registerBottomLeftInfo(app);
          if (typeof registerBottomCenterControls === 'function') registerBottomCenterControls(app);
          if (typeof registerBottomRightControls === 'function') registerBottomRightControls(app);
          if (typeof registerBottomControls === 'function') registerBottomControls(app);
          if (typeof registerMobileHeader === 'function') registerMobileHeader(app);

          // Bottom Panel Buttons
          if (typeof registerChatButton === 'function') registerChatButton(app);
          if (typeof registerReactButton === 'function') registerReactButton(app);
          if (typeof registerSettingsButton === 'function') registerSettingsButton(app);
          if (typeof registerTipButtons === 'function') registerTipButtons(app);
          if (typeof registerCameraMicControls === 'function') registerCameraMicControls(app);
          if (typeof registerSettingsTrigger === 'function') registerSettingsTrigger(app);
          if (typeof registerToggleScreensize === 'function') registerToggleScreensize(app);
          if (typeof registerCameraButton === 'function') registerCameraButton(app);
          if (typeof registerMicrophoneButton === 'function') registerMicrophoneButton(app);
          if (typeof registerEndCallButton === 'function') registerEndCallButton(app);

            // Calling Flow

          if (typeof registerLoadingSpinner === 'function') registerLoadingSpinner(app);
          if (typeof registerIncomingCall === 'function') registerIncomingCall(app);
          if (typeof registerCallingCard === 'function') registerCallingCard(app);
          if (typeof registerAcceptedCreatorCard === 'function') registerAcceptedCreatorCard(app);
          if (typeof registerCallPermissionCard === 'function') registerCallPermissionCard(app);
          if (typeof registerCallRejected=== 'function') registerCallRejected(app);
          if (typeof registerCallMissed=== 'function') registerCallMissed(app);
          if (typeof registerWaitingToJoin=== 'function') registerWaitingToJoin(app);
          if (typeof registerWaitingAvatar === "function") { registerWaitingAvatar(app);}

          

          // Mount Vue app to #app
          console.log('[Vue] Mounting to #app');
          app.mount('#app');
        } catch (error) {
          console.error('Error creating Vue app:', error);
        }
      }

      function ensureVueReady() {
        if (!window.Vue || typeof Vue.createApp !== 'function') {
          console.warn('Vue not ready yet. Retrying...');
          setTimeout(ensureVueReady, 100);
          return;
        }

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', startApp, { once: true });
        } else {
          startApp();
        }
      }

      ensureVueReady();
    })();
  </script>




  <script>
    /* ======================================================================
     * EXACT LOGIN FLOW HANDLER (YOUR REQchime-ui:RED ORDER + our CallHandler.init)
     * ==================================================================== */
    document.addEventListener("event:user:loggedin", (e) => {
      const userId = e?.detail?.userId;
      if (!userId) {
        console.warn("[SocketHandler] event:user:loggedin missing userId");
        return;
      }

      try {
        SocketHandler.identifyCurrentUser(userId);
        SocketHandler._initializeSocketConnection();
        CallHandler.init(); // √¢‚Ä†¬ê initialize the class IMMEDIATELY after starting socket
        console.log(
          `[SocketHandler] Initialized WebSocket for user: ${userId}`
        );
      } catch (err) {
        console.error(
          "[SocketHandler] Failed to initialize after login:",
          err
        );
      }
    });



    // √∞≈∏‚Äù¬µ EXACT button √¢‚Ä†‚Äô dispatch event:user:loggedin (DO NOT CHANGE THIS PATTERN)
    document
      .getElementById("btnLoginRegister")
      .addEventListener("click", () => {
        const userId = document.getElementById("currentUserId").value.trim();
        if (!userId) {
          console.warn("Missing userId");
          DebugLogger.addLog(
            "initialize",
            "CRITICAL",
            "btnLoginRegister",
            "Enter your User ID first."
          );
          return;
        }
        document.dispatchEvent(
          new CustomEvent("event:user:loggedin", { detail: { userId } })
        );
        console.log("[Demo] Dispatched event:user:loggedin for", userId);
      });

    // Video Effects: Blur Level
    document.getElementById("blurLevelSelect")?.addEventListener("change", (e) => {
      const level = e.target.value;
      console.log("[Demo] Blur level changed to:", level);
      if (typeof DebugLogger !== "undefined") {
        DebugLogger.system(`Blur level changed to: ${level}`);
      }
      if (typeof coreChime !== "undefined") {
        coreChime.setVideoBlur(level).catch((err) => {
          console.error("[Demo] Failed to set blur:", err);
        });
      }
    });

    // Video Effects: Background Image
    document.getElementById("backgroundSelect")?.addEventListener("change", (e) => {
      const imageUrl = e.target.value;
      console.log("[Demo] Background changed to:", imageUrl || "None");
      if (typeof DebugLogger !== "undefined") {
        DebugLogger.system(`Background changed to: ${imageUrl || 'none'}`);
      }
      if (typeof coreChime !== "undefined") {
        coreChime.setBackgroundImage(imageUrl || null).catch((err) => {
          console.error("[Demo] Failed to set background:", err);
        });
      }
    });

    /* =========================================================================
     * OPTIONAL LOCAL BRIDGE (for demo/testing only √¢‚Ç¨‚Äù delete if backend fans out)
     * Translates local call:initiate √¢‚Ä†‚Äô socket call:incoming to the callee.
     * ========================================================================= */
    // document.addEventListener(CallHandler.FLAGS.CALL_INITIATE, (e) => {
    //   const d = e && e.detail ? e.detail : undefined;
    //   console.log("[CallHandler] LOCAL BRIDGE call:initiate", d);
    //   if (!d) { console.log("[CallHandler] bridge missing detail"); return; }
    //   if (d.callerId === undefined || d.callerId === "") { console.log("[CallHandler] bridge missing callerId"); return; }
    //   if (d.calleeId === undefined || d.calleeId === "") { console.log("[CallHandler] bridge missing calleeId"); return; }
    //   if (d.type === undefined     || d.type === "")     { console.log("[CallHandler] bridge missing type"); return; }
    //   if (d.role === undefined     || d.role === "")     { console.log("[CallHandler] bridge missing caller role"); return; }

    //   SocketHandler.sendSocketMessage({
    //     flag: CallHandler.FLAGS.CALL_INCOMING,
    //     payload: { to: d.calleeId, callType: d.type, callerId: d.callerId, calleeId: d.calleeId, role: d.role },
    //     schema: CallHandler.SCHEMA.initiate
    //   });
    //   console.log("[CallHandler] LOCAL BRIDGE sent CALL_INCOMING to callee");
    // });
  </script>

  <script>
    /* ======================================================================
     * AUTOMATIC LAYOUT SYSTEM
     * Applies Tailwind grid layouts based on active participants
     * ==================================================================== */
    (function () {
      const stage = document.getElementById("video-containers");
      if (!stage) {
        console.warn("[Layout System] #video-containers not found");
        return;
      }

      // Get all tile elements by ID
      const host = document.getElementById("host-container");
      const collab1 = document.getElementById("collab1-container");
      const collab2 = document.getElementById("collab2-container");
      const collab3 = document.getElementById("collab3-container");
      const attendee = document.getElementById("attendee-container");

      if (!host || !collab1 || !collab2 || !collab3 || !attendee) {
        console.warn("[Layout System] Missing tile elements");
        return;
      }

      // One source of truth for base classes
      const BASE_TILE =
        "tile flex items-center justify-center rounded-xl bg-black text-white video-card";

      const MINI_OVERLAY = "mini-overlay";
      const FULL_VIEW = "full-view";

      function setBase(el) {
        if (el) {
          el.className =
            BASE_TILE +
            " " +
            (el.classList.contains("hidden") ? "hidden" : "");
        }
      }

      function hide(el) {
        if (el) el.className = BASE_TILE + " video-card hidden";
      }

      function show(el, extra = "") {
        if (el) {
          el.className = BASE_TILE + " " + (extra ? extra : "");
        }
      }

      const layouts = {
        // Host main (full view) + Attendee mini overlay
        host_attendee() {
          show(host, FULL_VIEW);
          hide(collab1);
          hide(collab2);
          hide(collab3);
          show(attendee, MINI_OVERLAY);
          console.log(
            "[Layout System] Applied: host_attendee (1 host + 1 attendee)"
          );
        },

        // Attendee main (full view) + Host mini overlay
        host_attendee_mainAtt() {
          show(attendee, FULL_VIEW);
          show(host, MINI_OVERLAY);
          hide(collab1);
          hide(collab2);
          hide(collab3);
          console.log(
            "[Layout System] Applied: host_attendee_mainAtt (attendee main)"
          );
        },

        // 2√É‚Äî2 grid: Host + 3 Collaborators
        host_3collabs() {
          show(host, "col-span-6 row-span-1 row-start-1 col-start-1");
          show(collab1, "col-span-6 row-span-1 row-start-1 col-start-7");
          show(collab2, "col-span-6 row-span-1 row-start-2 col-start-1");
          show(collab3, "col-span-6 row-span-1 row-start-2 col-start-7");
          show(attendee, MINI_OVERLAY);
          console.log("[Layout System] Applied: host_3collabs (2x2 grid)");
        },

        // Split: Host (left) + 1 Collaborator (right) - both full height
        host_1collab() {
          show(host, "col-span-6 row-span-2 row-start-1 col-start-1");
          show(collab1, "col-span-6 row-span-2 row-start-1 col-start-7");
          hide(collab2);
          hide(collab3);
          show(attendee, MINI_OVERLAY);
          console.log(
            "[Layout System] Applied: host_1collab (side-by-side full height)"
          );
        },

        // Host centered top + 2 Collaborators side-by-side on bottom + Attendee overlay (all same size)
        host_2collabs() {
          show(host, "col-span-6 row-span-1 row-start-1 col-start-4"); // centered at top, same size as collabs
          show(collab1, "col-span-6 row-span-1 row-start-2 col-start-1"); // bottom left
          show(collab2, "col-span-6 row-span-1 row-start-2 col-start-7"); // bottom right
          hide(collab3);
          show(attendee, MINI_OVERLAY);
          console.log(
            "[Layout System] Applied: host_2collabs (host centered top + 2 collabs bottom - all same size + attendee overlay)"
          );
        },
      };

      // Track current layout and re-entrancy protection
      let currentLayout = null;
      let isApplyingLayout = false;

      function applyLayout(name) {
        if (name === undefined || isApplyingLayout) return;

        // Skip if layout hasn't changed
        if (currentLayout === name) {
          console.log(`[Layout System] Layout already applied: ${name}`);
          return;
        }

        isApplyingLayout = true;
        console.log(`[Layout System] Applying layout: ${name}`);

        // Disconnect observer temporarily to prevent infinite loop
        observer.disconnect();

        // Reset all tiles to base state
        [host, collab1, collab2, collab3, attendee].forEach(setBase);

        // Apply the specified layout
        if (layouts[name]) {
          layouts[name]();
        } else {
          console.warn(`[Layout System] Unknown layout: ${name}`);
        }

        stage.setAttribute("data-layout", name);
        currentLayout = name;

        // Reconnect observer after layout is applied
        setTimeout(() => {
          observer.observe(stage, {
            attributes: true,
            attributeFilter: ["class"],
            subtree: true,
          });
          isApplyingLayout = false;
        }, 50);
      }

      // Automatic layout detection based on active participants
      function autoDetectAndApplyLayout() {
        const tiles = [host, collab1, collab2, collab3, attendee];
        const activeTiles = tiles.filter(
          (t) => !t.classList.contains("hidden")
        );
        const activeCount = activeTiles.length;

        console.log(
          `[Layout System] Auto-detecting layout for ${activeCount} active participants`
        );

        // Get active participants by type
        const hasHost = !host.classList.contains("hidden");
        const hasAttendee = !attendee.classList.contains("hidden");
        const activeCollabs = [collab1, collab2, collab3].filter(
          (c) => !c.classList.contains("hidden")
        );
        const collabCount = activeCollabs.length;

        // Determine the best layout based on active participants
        let targetLayout = "host_attendee";

        console.log(
          `[Layout Detection] hasHost: ${hasHost}, hasAttendee: ${hasAttendee}, collabCount: ${collabCount}`
        );

        if (activeCount === 1) {
          // Single participant
          if (hasHost) targetLayout = "host_attendee";
          else targetLayout = "host_attendee_mainAtt";
        } else if (activeCount === 2) {
          // Two participants
          if (hasHost && hasAttendee) {
            targetLayout = "host_attendee";
            console.log(
              `[Layout Detection] 2 participants: Host + Attendee √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else if (hasHost && collabCount === 1) {
            targetLayout = "host_1collab";
            console.log(
              `[Layout Detection] 2 participants: Host + 1 Collab √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else {
            targetLayout = "host_attendee";
            console.log(
              `[Layout Detection] 2 participants: Unknown combination √¢‚Ä†‚Äô ${targetLayout}`
            );
          }
        } else if (activeCount === 3) {
          // Three participants
          if (hasHost && collabCount === 1) {
            targetLayout = "host_1collab";
            console.log(
              `[Layout Detection] 3 participants: Host + 1 Collab + (other) √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else if (hasHost && collabCount === 2) {
            targetLayout = "host_2collabs";
            console.log(
              `[Layout Detection] 3 participants: Host + 2 Collabs √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else if (hasHost && hasAttendee) {
            // Host + Attendee + 1 Collab (no 2 collabs case exists)
            targetLayout = "host_1collab";
            console.log(
              `[Layout Detection] 3 participants: Host + Attendee + 1 Collab √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else {
            targetLayout = "host_3collabs";
            console.log(
              `[Layout Detection] 3 participants: Unknown √¢‚Ä†‚Äô ${targetLayout}`
            );
          }
        } else if (activeCount === 4) {
          // Four participants: Could be Host + 2 Collabs + Attendee OR Host + 3 Collabs
          if (hasHost && hasAttendee && collabCount === 2) {
            // Host + 2 Collabs + Attendee
            targetLayout = "host_2collabs";
            console.log(
              `[Layout Detection] 4 participants: Host + 2 Collabs + Attendee √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else if (hasHost && collabCount === 3) {
            // Host + 3 Collabs
            targetLayout = "host_3collabs";
            console.log(
              `[Layout Detection] 4 participants: Host + 3 Collabs √¢‚Ä†‚Äô ${targetLayout}`
            );
          } else {
            // Fallback
            targetLayout = "host_2collabs";
            console.log(
              `[Layout Detection] 4 participants: Fallback √¢‚Ä†‚Äô ${targetLayout}`
            );
          }
        } else if (activeCount === 5) {
          // Five participants: Host + 3 Collabs + Attendee
          targetLayout = "host_3collabs";
          console.log(
            `[Layout Detection] 5 participants: Host + 3 Collabs + Attendee √¢‚Ä†‚Äô ${targetLayout}`
          );
        } else {
          // Default for any other count
          console.log(
            "[Layout Detection] Applying default layout for active count:",
            activeCount
          );
          targetLayout = "host_attendee";
        }

        // Only apply if layout is different
        if (targetLayout !== currentLayout) {
          applyLayout(targetLayout);
        }
      }

      // Watch for changes to active participants using MutationObserver
      const observer = new MutationObserver(() => {
        // Prevent infinite loops by checking if we're already applying layout
        if (isApplyingLayout) {
          return;
        }

        // Debounce to avoid excessive calls
        if (window.layoutUpdateTimeout) {
          clearTimeout(window.layoutUpdateTimeout);
        }
        window.layoutUpdateTimeout = setTimeout(() => {
          autoDetectAndApplyLayout();
        }, 100);
      });

      // Observe the stage for class changes on tiles
      observer.observe(stage, {
        attributes: true,
        attributeFilter: ["class"],
        subtree: true,
      });

      // Initial layout detection
      autoDetectAndApplyLayout();

      console.log("[Layout System] √¢≈ì‚Ä¶ Initialized automatic layout system");

      // Expose layout functions globally for manual testing if needed
      window.autoLayout = {
        applyLayout,
        autoDetectAndApplyLayout,
        layouts,
      };

      // Test function to show containers for visual testing
      window.showTestTiles = function () {
        console.log(
          "[Layout System] Showing test tiles for visual inspection..."
        );
        host.classList.remove("hidden");
        collab1.classList.remove("hidden");
        collab2.classList.remove("hidden");
        collab3.classList.remove("hidden");
        attendee.classList.remove("hidden");
      };

      // Test function to hide all tiles
      window.hideTestTiles = function () {
        console.log("[Layout System] Hiding all test tiles...");
        host.classList.add("hidden");
        collab1.classList.add("hidden");
        collab2.classList.add("hidden");
        collab3.classList.add("hidden");
        attendee.classList.add("hidden");
      };

      console.log("[Layout System] √∞≈∏‚Äô¬° Test functions available:");
      console.log(
        "  - showTestTiles() // Show all 5 tiles with colored borders"
      );
      console.log("  - hideTestTiles() // Hide all tiles");
      console.log(
        "  - autoLayout.applyLayout('layout-name') // Apply specific layout"
      );
    })();
  </script>



  <!--

CallHandler.dipatchUI("caller:startCall");




    -->

    <!-- Prosenjit insert tile layout -->
    <script>
      (function () {
        function log(...args) { console.log('[LayoutButtons]', ...args); }
        function warn(...args) { console.warn('[LayoutButtons]', ...args); }
      
        // Wait for DOM ready and Vue mount (soft)
        function ready(fn) {
          if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(fn, 10);
          } else {
            document.addEventListener('DOMContentLoaded', fn, { once: true });
          }
        }
      
        ready(() => {
          log('initializing√¢‚Ç¨¬¶');
      
          // Find the "stage" that we need to control
          const stage = document.getElementById('stage') || document.getElementById('video-containers') || document.querySelector('[data-chime-templates]');
      
          if (!stage) {
            warn('no #stage, #video-containers, or [data-chime-templates] found √¢‚Ç¨‚Äù aborting.');
            return;
          }
      
          // Two markup styles we support:
          const hostA = stage.querySelector('[data-name="host"]');
          const collab1A = stage.querySelector('[data-name="collab1"]');
          const collab2A = stage.querySelector('[data-name="collab2"]');
          const collab3A = stage.querySelector('[data-name="collab3"]');
          const attendeeA = stage.querySelector('[data-name="attendee"], #attendee');
      
          // Style B (callFlowfinal IDs)
          const hostB = document.getElementById('host-container');
          const collab1B = document.getElementById('collab1-container');
          const collab2B = document.getElementById('collab2-container');
          const collab3B = document.getElementById('collab3-container');
          const attendeeB = document.getElementById('attendee-container');
      
          // Pick style (prefer B if any B tile exists)
          const useB = !!(hostB || collab1B || attendeeB);
          const host = useB ? hostB : hostA;
          const collab1 = useB ? collab1B : collab1A;
          const collab2 = useB ? collab2B : collab2A;
          const collab3 = useB ? collab3B : collab3A;
          const attendee = useB ? attendeeB : attendeeA;
      
          if (!host || !attendee) {
            warn('host or attendee tiles not found √¢‚Ç¨‚Äù UI will still attempt to apply classes but check element IDs/data-names.');
          }
      
          // base & helper functions (keeps existing "video-card" or "hidden")
          const BASE_TILE    = "tile flex items-center justify-center rounded-xl bg-black text-white";
          const MINI_OVERLAY = "absolute bottom-[10rem] right-4 w-[25rem] h-[15rem] z-50 rounded-xl overflow-hidden";
          const FULL_VIEW    = "absolute inset-0 w-auto h-auto rounded-xl";
      
          function setBase(el) {
            if (!el) return;
            // preserve existing 'hidden' or 'video-card'
            const wasHidden = el.classList.contains('hidden');
            const hasVideoCard = el.classList.contains('video-card');
            el.className = BASE_TILE + (hasVideoCard ? ' video-card' : '') + (wasHidden ? ' hidden' : '');
            // store base for reference
            el.dataset.base = BASE_TILE;
          }
          function hide(el) { if (!el) return; el.className = BASE_TILE + (el.classList.contains('video-card') ? ' video-card' : '') + ' hidden'; }
          function show(el, extra='') { if (!el) return; el.className = BASE_TILE + (extra ? ' ' + extra : ''); }
      
          // Central layout applier used by clicks
          function applyLocalLayout(name) {
            // reset base first
            [host, collab1, collab2, collab3, attendee].forEach(setBase);
      
            switch (name) {
              case 'host_attendee':
                if (host) show(host, FULL_VIEW);
                if (collab1) hide(collab1);
                if (collab2) hide(collab2);
                if (collab3) hide(collab3);
                if (attendee) show(attendee, MINI_OVERLAY);
                break;
      
              case 'host_attendee_mainAtt':
                if (attendee) show(attendee, FULL_VIEW);
                if (host) show(host, MINI_OVERLAY);
                if (collab1) hide(collab1);
                if (collab2) hide(collab2);
                if (collab3) hide(collab3);
                break;
      
              case 'host_3collabs':
                if (host) show(host, 'col-span-6 row-span-1 row-start-1 col-start-1');
                if (collab1) show(collab1, 'col-span-6 row-span-1 row-start-1 col-start-7');
                if (collab2) show(collab2, 'col-span-6 row-span-1 row-start-2 col-start-1');
                if (collab3) show(collab3, 'col-span-6 row-span-1 row-start-2 col-start-7');
                if (attendee) show(attendee, MINI_OVERLAY);
                break;
      
              case 'host_1collab':
                if (host) show(host, 'col-span-6 row-span-2 row-start-1 col-start-1');
                if (collab1) show(collab1, 'col-span-6 row-span-2 row-start-1 col-start-7');
                if (collab2) hide(collab2);
                if (collab3) hide(collab3);
                if (attendee) show(attendee, MINI_OVERLAY);
                break;
      
              case 'host_2collabs':
                if (host) show(host, 'col-span-6 row-span-1 row-start-1 col-start-4');
                if (collab1) show(collab1, 'col-span-6 row-span-1 row-start-2 col-start-1');
                if (collab2) show(collab2, 'col-span-6 row-span-1 row-start-2 col-start-7');
                if (collab3) hide(collab3);
                if (attendee) show(attendee, MINI_OVERLAY);
                break;
      
              default:
                warn('unknown layout:', name);
                return;
            }
      
            // reflect layout on stage attribute (helps other code/readers)
            try { stage.setAttribute('data-layout', name); } catch (e) { /* ignore */ }
      
            log('applied local layout √¢‚Ä†‚Äô', name);
          }
      
          // Public button handler:
          function onLayoutButtonClick(layoutName) {
            log('button clicked √¢‚Ä†‚Äô', layoutName);
      
            // 1) Try to call a global applyLayout if available (some files create this)
            try {
              if (typeof window.applyLayout === 'function') {
                log('calling window.applyLayout(...)');
                window.applyLayout(layoutName);
                try { stage.setAttribute('data-layout', layoutName); } catch (e) {}
                return;
              }
            } catch (e) { /* ignore */ }
      
            // 2) Try to call a known global LayoutSystem.applyLayout (common naming) - safe-guarded
            try {
              if (window.LayoutSystem && typeof window.LayoutSystem.applyLayout === 'function') {
                log('calling LayoutSystem.applyLayout(...)');
                window.LayoutSystem.applyLayout(layoutName);
                try { stage.setAttribute('data-layout', layoutName); } catch (e) {}
                return;
              }
            } catch (e) { /* ignore */ }
      
            // 3) Fallback to local implementation
            applyLocalLayout(layoutName);
      
            // 4) Emit a custom event so other code can react if desired
            document.dispatchEvent(new CustomEvent('layout:applied', { detail: { layout: layoutName } }));
          }
      
          // Attach direct listeners to existing buttons (copy/paste area in data-chime-templates)
          function bindExistingButtons() {
            const btns = Array.from(document.querySelectorAll('button[data-layout]'));
            btns.forEach(btn => {
              // avoid duplicate handlers
              if (btn.__layout_bound) return;
              btn.addEventListener('click', (e) => {
                e.preventDefault();
                const name = btn.getAttribute('data-layout');
                if (!name) return;
                onLayoutButtonClick(name);
              }, { passive: false });
              btn.__layout_bound = true;
            });
            log('bound', btns.length, 'existing buttons');
          }
      
          bindExistingButtons();
      
          // event delegation for buttons that may be rendered later by Vue
          document.addEventListener('click', (e) => {
            const btn = e.target.closest && e.target.closest('button[data-layout]');
            if (!btn) return;
            // ignore if already handled by direct listener
            if (btn.__layout_bound) return;
            const name = btn.getAttribute('data-layout');
            if (!name) return;
            onLayoutButtonClick(name);
          }, { passive: true });
      
          // Optional: keep observer to re-assert base classes if another layout system mutates DOM
          try {
            const observer = new MutationObserver(() => {
              // keep 'tile' class present so CSS rules continue to apply
              [host, collab1, collab2, collab3, attendee].forEach(el => {
                if (!el) return;
                if (!el.classList.contains('tile')) el.classList.add('tile');
              });
            });
            observer.observe(stage, { attributes: true, childList: true, subtree: true });
          } catch (err) {
            // not critical
          }
      
          // --- NEW: apply default layout on initial load ---
          try {
            // ensure base classes exist before applying
            [host, collab1, collab2, collab3, attendee].forEach(setBase);
            // apply default layout
            const defaultLayout = 'host_attendee';
            log('applying default layout on load √¢‚Ä†‚Äô', defaultLayout);
            onLayoutButtonClick(defaultLayout);
          } catch (err) {
            warn('failed to apply default layout:', err);
          }
      
          log('ready √¢‚Ç¨‚Äù click a button to apply a layout. If nothing changes, check console for warnings.');
        });
      })();
      </script>

  <script>
  // Debug controls for testing chat without being in a call
  (function initDebugChatControls() {
    // Show chat button
    document.getElementById('debug-show-chat')?.addEventListener('click', () => {
      const chatPanel = document.getElementById('chatPanel');
      if (chatPanel) {
        chatPanel.classList.remove('hidden');
        chatPanel.setAttribute('aria-hidden', 'false');
        console.log('[Debug] Chat panel shown');
      }
    });

    // Send message as self
    document.getElementById('debug-send-self')?.addEventListener('click', () => {
      const input = document.getElementById('debug-chat-input-self');
      const message = input.value.trim();
      if (!message) return;

      window.dispatchEvent(new CustomEvent('receiveChatMessage', {
        detail: {
          message: message,
          sender: 'You',
          timestamp: Date.now(),
          isSelf: true
        }
      }));
      input.value = '';
      console.log('[Debug] Sent message as self:', message);
    });

    // Send message as other
    document.getElementById('debug-send-other')?.addEventListener('click', () => {
      const input = document.getElementById('debug-chat-input-other');
      const message = input.value.trim();
      if (!message) return;

      window.dispatchEvent(new CustomEvent('receiveChatMessage', {
        detail: {
          message: message,
          sender: 'Test User',
          timestamp: Date.now(),
          isSelf: false
        }
      }));
      input.value = '';
      console.log('[Debug] Sent message as other:', message);
    });

    // Send emoji test
    document.getElementById('debug-send-emoji')?.addEventListener('click', () => {
      window.dispatchEvent(new CustomEvent('receiveChatMessage', {
        detail: {
          message: 'Hello! √¢¬ù¬§√Ø¬∏¬è√∞≈∏Àú≈†√∞≈∏≈Ω‚Ä∞',
          sender: 'Emoji Tester',
          timestamp: Date.now(),
          isSelf: false
        }
      }));
      console.log('[Debug] Sent emoji message');
    });

    // Send test media card
    document.getElementById('debug-send-media')?.addEventListener('click', () => {
      const testMediaCard = [{
        scope: 'media',
        item: {
          id: 999,
          type: 'video',
          durationOrCount: '5:30',
          creator: { username: 'TestCreator' },
          thumbnail_url: 'https://picsum.photos/seed/test/400/300',
          title: 'Test Media Card',
          is_subscription: true,
          subscription: { price: 9.99 },
          is_p2v: true,
          p2v: { price: 4.99 }
        }
      }];

      window.dispatchEvent(new CustomEvent('ingest-cards', { detail: testMediaCard }));
      console.log('[Debug] Sent test media card');
    });

    // Send test merch/product card
    document.getElementById('debug-send-merch')?.addEventListener('click', () => {
      const testMerchCard = [{
        scope: 'merch',
        item: {
          id: 888,
          discount_percentage: 20,
          creator: { username: 'TestShop' },
          gallery: ['https://picsum.photos/seed/merch/400/400'],
          title: 'Test Product - Cool Merch Item',
          can_subscribe: true,
          subscribe_data: { price: 19.99 },
          can_buy: true,
          price: 49.99,
          tier_id: 5
        }
      }];

      window.dispatchEvent(new CustomEvent('ingest-cards', { detail: testMerchCard }));
      console.log('[Debug] Sent test merch card');
    });

    // Send test subscription card
    document.getElementById('debug-send-subscription')?.addEventListener('click', () => {
      const testSubCard = [{
        scope: 'subs',
        item: {
          id: 777,
          creator: { username: 'TestCreator' },
          background_image: 'https://picsum.photos/seed/sub/600/400',
          title: 'VIP Test Tier',
          price: 29.99
        }
      }];

      window.dispatchEvent(new CustomEvent('ingest-cards', { detail: testSubCard }));
      console.log('[Debug] Sent test subscription card');
    });

    // Send test gift
    document.getElementById('debug-send-gift')?.addEventListener('click', () => {
      window.dispatchEvent(new CustomEvent('receiveGift', {
        detail: {
          giftId: Math.floor(Math.random() * 7) + 1,
          qty: 5,
          sender: 'Gift Tester'
        }
      }));
      console.log('[Debug] Sent test gift');
    });

    // Send test reaction
    document.getElementById('debug-send-reaction')?.addEventListener('click', () => {
      const reactions = ['√∞≈∏Àú‚Ç¨', '√¢¬ù¬§√Ø¬∏¬è', '√∞≈∏‚Äò¬ç', '√∞≈∏≈Ω‚Ä∞', '√∞≈∏‚Äù¬•', '√∞≈∏Àú¬ç', '√∞≈∏¬§¬£'];
      const emoji = reactions[Math.floor(Math.random() * reactions.length)];
      window.dispatchEvent(new CustomEvent('receiveReaction', {
        detail: {
          emoji: emoji,
          sender: 'Reaction Tester'
        }
      }));
      console.log('[Debug] Sent test reaction:', emoji);
    });

    console.log('[Debug] √¢≈ì‚Ä¶ Test chat controls initialized');
  })();

  // Mock Data Display Update Function
  (function initMockDataDisplay() {
    function updateMockDataDisplay() {
      if (typeof window === 'undefined' || !window.mockCallData) return;
      const display = document.getElementById('mock-data-display');
      if (display) {
        display.textContent = JSON.stringify(window.mockCallData, null, 2);
      }
    }

    // Update on load
    window.addEventListener('DOMContentLoaded', updateMockDataDisplay);
    
    // Update periodically to catch dynamic changes
    setInterval(updateMockDataDisplay, 1000);
    
    console.log('[Debug] √¢≈ì‚Ä¶ Mock data display initialized');
  })();

  // Grace Period Controls
  (function initGracePeriodControls() {
    document.getElementById('btn-grace-start')?.addEventListener('click', () => {
      if (typeof CallHandler !== 'undefined' && CallHandler.handleGracePeriodStart) {
        CallHandler.handleGracePeriodStart();
        document.getElementById('grace-status').textContent = 'TRUE';
      } else {
        console.error('[Grace] CallHandler.handleGracePeriodStart not found');
      }
    });

    document.getElementById('btn-grace-resume')?.addEventListener('click', () => {
      if (typeof CallHandler !== 'undefined' && CallHandler.handleGracePeriodResume) {
        CallHandler.handleGracePeriodResume();
        document.getElementById('grace-status').textContent = 'FALSE';
      } else {
        console.error('[Grace] CallHandler.handleGracePeriodResume not found');
      }
    });

    document.getElementById('btn-grace-end-fail')?.addEventListener('click', () => {
      if (typeof CallHandler !== 'undefined' && CallHandler.handleGracePeriodEndFail) {
        CallHandler.handleGracePeriodEndFail();
        document.getElementById('grace-status').textContent = 'FALSE';
      } else {
        console.error('[Grace] CallHandler.handleGracePeriodEndFail not found');
      }
    });

    console.log('[Debug] √¢≈ì‚Ä¶ Grace period controls initialized');
  })();

  // Debug Call State Display Update Function
  (function initDebugCallState() {
    function updateDebugCallState() {
      if (typeof window === 'undefined' || !window.mockCallData) return;
      const data = window.mockCallData;
      
      document.getElementById('debug-call-type').textContent = data.callType || '-';
      document.getElementById('debug-media-type').textContent = data.mediaType || '-';
      document.getElementById('debug-your-role').textContent = data.currentUserRole || '-';
      document.getElementById('debug-your-side').textContent = data.currentUserSide || '-';
      document.getElementById('debug-grace').textContent = data.isInGrace ? 'TRUE' : 'FALSE';
      
      const currentUserEl = document.getElementById('debug-current-user');
      if (currentUserEl && data.currentUser) {
        currentUserEl.innerHTML = `
          User ID: ${data.currentUser.userId}<br>
          Username: @${data.currentUser.username}<br>
          Display Name: ${data.currentUser.displayName}<br>
          Avatar: ${data.currentUser.avatar || 'N/A'}<br>
          Initials: ${data.currentUser.initials}<br>
          <strong>Is Creator: ${data.currentUser.isCreator ? 'YES' : 'NO'}</strong><br>
          <strong>Is Fan: ${data.currentUser.isFan ? 'YES' : 'NO'}</strong>
        `;
      }
      
      const targetUserEl = document.getElementById('debug-target-user');
      if (targetUserEl && data.targetUser) {
        targetUserEl.innerHTML = `
          User ID: ${data.targetUser.userId}<br>
          Username: @${data.targetUser.username}<br>
          Display Name: ${data.targetUser.displayName}<br>
          Avatar: ${data.targetUser.avatar || 'N/A'}<br>
          Initials: ${data.targetUser.initials}<br>
          <strong>Is Creator: ${data.targetUser.isCreator ? 'YES' : 'NO'}</strong><br>
          <strong>Is Fan: ${data.targetUser.isFan ? 'YES' : 'NO'}</strong>
        `;
      }
    }

    // Update on data changes
    setInterval(updateDebugCallState, 1000);
    
    console.log('[Debug] √¢≈ì‚Ä¶ Call state display initialized');
  })();

  // Debug Call Settings Display Update Function
  (function initDebugCallSettings() {
    function updateDebugCallSettings() {
      if (typeof window === 'undefined' || !window.settings) return;
      const settings = window.settings;
      
      const camStatusEl = document.getElementById('debug-call-cam-status');
      if (camStatusEl) {
        camStatusEl.textContent = settings.callCamStatus ? 'true' : 'false';
      }
      
      const micStatusEl = document.getElementById('debug-call-mic-status');
      if (micStatusEl) {
        micStatusEl.textContent = settings.callMicStatus ? 'true' : 'false';
      }
    }

    // Update on interval
    setInterval(updateDebugCallSettings, 1000);
    
    // Initial update
    updateDebugCallSettings();
    
    console.log('[Debug] √¢≈ì‚Ä¶ Call settings display initialized');
  })();
  </script>





















<div class="container mt-4">
  <h1 class="mb-4">CamMic Permissions Test</h1>
  
  <!-- Important Notice -->
  <div class="alert alert-info mb-4" role="alert">
    <h5 class="alert-heading">‚ö†Ô∏è Important Testing Instructions</h5>
    <ul class="mb-0">
      <li><strong>Always click "Initialize" first</strong> before testing any other actions</li>
      <li><strong>Monitor console logs</strong> for detailed operation information and any issues</li>
      <li>There is a <strong>container at the bottom</strong> that will automatically show the camera feed when preview is enabled</li>
    </ul>
  </div>
  
  <!-- CamMic Actions Documentation Table -->
  <div class="mb-5">
    <h2 class="mb-3">CamMic Actions Documentation</h2>
    <div class="table-responsive">
      <table class="table table-bordered table-hover">
        <thead class="table-light">
          <tr>
            <th style="width: 15%">Title</th>
            <th style="width: 12%">Action</th>
            <th style="width: 30%">Description</th>
            <th style="width: 20%">Checklist</th>
            <th style="width: 23%">How to Wire Up</th>
          </tr>
        </thead>
        <tbody>
          <!-- Initialize -->
          <tr>
            <td><strong>Initialize</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Initialize'); window.dispatchEvent(new CustomEvent('CamMic:Init'));">
                Initialize
  </button>
            </td>
            <td>
              <strong>How:</strong> Dispatches initialization event that sets up the CamMicPermissionsHandler system, caches UI elements, and registers event listeners.<br><br>
              <strong>Why:</strong> Required first step to initialize the handler and prepare the system for permission requests. Must be called before any other actions.<br><br>
              <strong>Expected:</strong> Handler initializes, UI elements are cached, event listeners are registered. System is ready for permission operations.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Handler initialized</li>
                <li>‚òê UI elements cached</li>
                <li>‚òê Event listeners registered</li>
                <li>‚òê System ready for operations</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Init'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Init'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Check Permissions -->
          <tr>
            <td><strong>Check Permissions</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Check Permissions'); window.dispatchEvent(new CustomEvent('CamMic:Permissions:Check'));">
                Check
  </button>
            </td>
            <td>
              <strong>How:</strong> Queries current permission states for camera and microphone without requesting permissions.<br><br>
              <strong>Why:</strong> Allows checking permission status before making requests. Useful for determining if permissions are already granted or need to be requested.<br><br>
              <strong>Expected:</strong> Permission states are checked and logged. Returns current state: "granted", "denied", or "prompt". No user prompt is shown.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permission states queried</li>
                <li>‚òê Camera permission state returned</li>
                <li>‚òê Microphone permission state returned</li>
                <li>‚òê No permission prompt shown</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Permissions:Check'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Permissions:Check'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Watch Permissions -->
          <tr>
            <td><strong>Watch Permissions</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Watch Permissions'); window.dispatchEvent(new CustomEvent('CamMic:Permissions:WatchStart'));">
                Watch
  </button>
            </td>
            <td>
              <strong>How:</strong> Starts monitoring permission state changes. Sets up listeners to detect when permissions are granted or denied.<br><br>
              <strong>Why:</strong> Allows real-time detection of permission changes. Useful for updating UI when user grants/denies permissions in browser settings.<br><br>
              <strong>Expected:</strong> Permission watching starts. System will detect and log permission changes. Events are fired when permissions change.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permission watching started</li>
                <li>‚òê Listeners registered for changes</li>
                <li>‚òê Changes will be detected</li>
                <li>‚òê Watching state is active</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Permissions:WatchStart'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Permissions:WatchStart'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Stop Watching -->
          <tr>
            <td><strong>Stop Watching</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Stop Watching'); window.dispatchEvent(new CustomEvent('CamMic:Permissions:WatchStop'));">
                Stop
  </button>
            </td>
            <td>
              <strong>How:</strong> Stops monitoring permission state changes. Removes listeners and cleans up watching functionality.<br><br>
              <strong>Why:</strong> Stops permission watching when no longer needed. Helps conserve resources and clean up event listeners.<br><br>
              <strong>Expected:</strong> Permission watching stops. Listeners are removed. System no longer detects permission changes.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permission watching stopped</li>
                <li>‚òê Listeners removed</li>
                <li>‚òê Watching state is inactive</li>
                <li>‚òê Resources cleaned up</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Permissions:WatchStop'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Permissions:WatchStop'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Request Camera -->
          <tr>
            <td><strong>Request Camera</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Request Camera'); window.dispatchEvent(new CustomEvent('CamMic:Request:Camera'));">
                Request
  </button>
            </td>
            <td>
              <strong>How:</strong> Requests camera permission from the user. Shows browser permission prompt if not already granted.<br><br>
              <strong>Why:</strong> Directly requests camera access without orchestrating full device setup. Useful for simple permission requests.<br><br>
              <strong>Expected:</strong> Browser permission prompt appears for camera. User grants/denies. Permission state is updated. No device selection or preview is started.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permission prompt shown</li>
                <li>‚òê User responds to prompt</li>
                <li>‚òê Permission state updated</li>
                <li>‚òê Camera permission granted or denied</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Request:Camera'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Request:Camera'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Request Microphone -->
          <tr>
            <td><strong>Request Microphone</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Request Microphone'); window.dispatchEvent(new CustomEvent('CamMic:Request:Microphone'));">
                Request
  </button>
            </td>
            <td>
              <strong>How:</strong> Requests microphone permission from the user. Shows browser permission prompt if not already granted.<br><br>
              <strong>Why:</strong> Directly requests microphone access without orchestrating full device setup. Useful for simple permission requests.<br><br>
              <strong>Expected:</strong> Browser permission prompt appears for microphone. User grants/denies. Permission state is updated. No device selection or streams are started.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permission prompt shown</li>
                <li>‚òê User responds to prompt</li>
                <li>‚òê Permission state updated</li>
                <li>‚òê Microphone permission granted or denied</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Request:Microphone'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Request:Microphone'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Request Both -->
          <tr>
            <td><strong>Request Both</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Request Both'); window.dispatchEvent(new CustomEvent('CamMic:Request:Both'));">
                Request
  </button>
            </td>
            <td>
              <strong>How:</strong> Requests both camera and microphone permissions from the user. Shows browser permission prompts if not already granted.<br><br>
              <strong>Why:</strong> Directly requests both permissions without orchestrating full device setup. Useful for simple permission requests for both devices.<br><br>
              <strong>Expected:</strong> Browser permission prompts appear for camera and microphone. User grants/denies. Permission states are updated. No device selection or streams are started.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permission prompts shown</li>
                <li>‚òê User responds to prompts</li>
                <li>‚òê Permission states updated</li>
                <li>‚òê Both camera and microphone permissions granted or denied</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Request:Both'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Request:Both'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- List Devices -->
          <tr>
            <td><strong>List Devices</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] List Devices'); window.dispatchEvent(new CustomEvent('CamMic:Devices:List'));">
                List
  </button>
            </td>
            <td>
              <strong>How:</strong> Queries and lists all available camera and microphone devices connected to the system.<br><br>
              <strong>Why:</strong> Allows discovery of available devices. Useful for device selection UI or debugging device availability.<br><br>
              <strong>Expected:</strong> Available devices are queried and logged. List includes device IDs, labels, and device information. Devices are available for selection.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Devices queried from system</li>
                <li>‚òê Camera devices listed</li>
                <li>‚òê Microphone devices listed</li>
                <li>‚òê Device information logged</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Devices:List'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Devices:List'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Stop Streams -->
          <tr>
            <td><strong>Stop Streams</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Stop Streams'); window.dispatchEvent(new CustomEvent('CamMic:Streams:Stop'));">
                Stop
  </button>
            </td>
            <td>
              <div style="background-color: #d1ecf1; border: 1px solid #0d6efd; border-radius: 4px; padding: 8px; margin-bottom: 10px; color: #0c5460;">
                <strong style="color: #0d6efd;">‚ö†Ô∏è Note:</strong> This action will only stop streams if there are active streams running. If no streams are active, this action will have no effect.
              </div>
              <strong>How:</strong> Stops all active camera and microphone media streams. Releases device access and cleans up resources.<br><br>
              <strong>Why:</strong> Properly releases device access when streams are no longer needed. Important for resource management and user privacy.<br><br>
              <strong>Expected:</strong> All active streams are stopped. Device tracks are stopped. Streams are released. Resources are cleaned up.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê All active streams stopped</li>
                <li>‚òê Camera tracks stopped</li>
                <li>‚òê Microphone tracks stopped</li>
                <li>‚òê Resources cleaned up</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Streams:Stop'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Streams:Stop'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Start Video Preview -->
          <tr>
            <td><strong>Start Video Preview</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Start Video Preview'); window.dispatchEvent(new CustomEvent('CamMic:Preview:Start'));">
                Start
  </button>
            </td>
            <td>
              <div style="background-color: #d1ecf1; border: 1px solid #0d6efd; border-radius: 4px; padding: 8px; margin-bottom: 10px; color: #0c5460;">
                <strong style="color: #0d6efd;">‚ö†Ô∏è Note:</strong> This action requires camera permissions to be granted first. If permissions are not granted, this action will fail. Use "Request Camera" or "Orchestrate Camera Only" first to obtain permissions.
              </div>
              <strong>How:</strong> Starts video preview by accessing camera and displaying feed in the video preview element.<br><br>
              <strong>Why:</strong> Allows starting video preview independently of orchestration. Useful for manual preview control or when permissions are already granted.<br><br>
              <strong>Expected:</strong> Video preview starts. Camera stream is accessed. Video element displays live camera feed. Preview is visible.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Camera stream accessed</li>
                <li>‚òê Video element updated</li>
                <li>‚òê Preview feed displayed</li>
                <li>‚òê Preview is active</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Preview:Start'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Preview:Start'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Orchestrate Both -->
          <tr>
            <td><strong>Orchestrate Both</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Orchestrate Both'); window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both'));">
                Orchestrate
  </button>
            </td>
            <td>
              <strong>How:</strong> Full orchestration flow: requests permissions, selects devices, starts streams, and enables video preview for both camera and microphone.<br><br>
              <strong>Why:</strong> Complete automated setup for video calls. Handles the entire workflow from permissions to active streams with preview.<br><br>
              <strong>Expected:</strong> Permissions requested, devices selected, streams started, video preview enabled. Completion event fired when done.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permissions requested</li>
                <li>‚òê Devices selected</li>
                <li>‚òê Streams started</li>
                <li>‚òê Video preview enabled</li>
                <li>‚òê Completion event fired</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Orchestrate Both (No Preview) -->
          <tr>
            <td><strong>Orchestrate Both (No Preview)</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Orchestrate Both (No Preview)'); window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both:NoPreview'));">
                Orchestrate
  </button>
            </td>
            <td>
              <strong>How:</strong> Full orchestration flow without video preview: requests permissions, selects devices, starts streams, but does not enable video preview.<br><br>
              <strong>Why:</strong> Complete setup for audio-only calls or when preview should be manually controlled. Useful when video preview isn't needed immediately.<br><br>
              <strong>Expected:</strong> Permissions requested, devices selected, streams started, but video preview NOT enabled. Completion event fired when done.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Permissions requested</li>
                <li>‚òê Devices selected</li>
                <li>‚òê Streams started</li>
                <li>‚òê Video preview NOT enabled</li>
                <li>‚òê Completion event fired</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both:NoPreview'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both:NoPreview'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Orchestrate Mic Only -->
          <tr>
            <td><strong>Orchestrate Mic Only</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Orchestrate Mic Only'); window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Microphone'));">
                Orchestrate
  </button>
            </td>
            <td>
              <strong>How:</strong> Full orchestration flow for microphone only: requests microphone permission, selects microphone device, starts audio stream.<br><br>
              <strong>Why:</strong> Complete automated setup for audio-only calls. Handles the entire workflow from permissions to active microphone stream.<br><br>
              <strong>Expected:</strong> Microphone permission requested, device selected, audio stream started. Completion event fired when done. No camera access.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Microphone permission requested</li>
                <li>‚òê Microphone device selected</li>
                <li>‚òê Audio stream started</li>
                <li>‚òê No camera access</li>
                <li>‚òê Completion event fired</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Microphone'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Microphone'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Orchestrate Camera Only -->
          <tr>
            <td><strong>Orchestrate Camera Only</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Orchestrate Camera Only'); window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera'));">
                Orchestrate
  </button>
            </td>
            <td>
              <strong>How:</strong> Full orchestration flow for camera only: requests camera permission, selects camera device, starts video stream, enables preview.<br><br>
              <strong>Why:</strong> Complete automated setup for video-only scenarios. Handles the entire workflow from permissions to active camera stream with preview.<br><br>
              <strong>Expected:</strong> Camera permission requested, device selected, video stream started, preview enabled. Completion event fired when done. No microphone access.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Camera permission requested</li>
                <li>‚òê Camera device selected</li>
                <li>‚òê Video stream started</li>
                <li>‚òê Video preview enabled</li>
                <li>‚òê No microphone access</li>
                <li>‚òê Completion event fired</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Orchestrate Camera Only (No Preview) -->
          <tr>
            <td><strong>Orchestrate Camera Only (No Preview)</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Orchestrate Camera Only (No Preview)'); window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera:NoPreview'));">
                Orchestrate
  </button>
            </td>
            <td>
              <strong>How:</strong> Full orchestration flow for camera only without preview: requests camera permission, selects device, starts stream, but does not enable preview.<br><br>
              <strong>Why:</strong> Complete setup for camera access without automatic preview. Useful for photo capture or when preview should be manually controlled.<br><br>
              <strong>Expected:</strong> Camera permission requested, device selected, video stream started, but preview NOT enabled. Completion event fired when done.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Camera permission requested</li>
                <li>‚òê Camera device selected</li>
                <li>‚òê Video stream started</li>
                <li>‚òê Video preview NOT enabled</li>
                <li>‚òê Completion event fired</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera:NoPreview'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera:NoPreview'));<br>
                };
              </code>
            </td>
          </tr>
          
          <!-- Get Device List -->
          <tr>
            <td><strong>Get Device List</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Get Device List'); window.dispatchEvent(new CustomEvent('CamMic:DeviceList:Check'));">
                Get List
  </button>
            </td>
            <td>
              <strong>How:</strong> Retrieves and displays the current list of available camera and microphone devices with their current selections.<br><br>
              <strong>Why:</strong> Shows current device state including which devices are available and which are currently selected. Useful for debugging and UI updates.<br><br>
              <strong>Expected:</strong> Device list is retrieved and logged. Shows available devices, selected devices, and device information. UI may be updated with device selections.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Event dispatched successfully</li>
                <li>‚òê Device list retrieved</li>
                <li>‚òê Available devices listed</li>
                <li>‚òê Selected devices shown</li>
                <li>‚òê Device information logged</li>
              </ul>
            </td>
            <td>
              <code class="small">
                // Direct dispatch<br>
                window.dispatchEvent(new CustomEvent('CamMic:DeviceList:Check'));<br>
                <br>
                // Or from button click<br>
                button.onclick = () => {<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:DeviceList:Check'));<br>
                };
              </code>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Test Wait Flows Documentation Table -->
  <div class="mb-5">
    <h2 class="mb-3">Test Wait Flows Documentation</h2>
    <div class="table-responsive">
      <table class="table table-bordered table-hover">
        <thead class="table-light">
          <tr>
            <th style="width: 15%">Title</th>
            <th style="width: 12%">Action</th>
            <th style="width: 30%">Description</th>
            <th style="width: 20%">Checklist</th>
            <th style="width: 23%">How to Wire Up</th>
          </tr>
        </thead>
        <tbody>
          <!-- Test Wait Flow: Both -->
          <tr>
            <td><strong>Both (Cam + Mic)</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Test Wait Flow - Both'); window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Both'));">
                Test Flow
  </button>
            </td>
            <td>
              <strong>How:</strong> Listens for test trigger, registers completion listener, dispatches orchestration event, waits for completion.<br><br>
              <strong>Why:</strong> Verifies async orchestration pattern works correctly with multiple event dispatches. Ensures completion is captured before proceeding.<br><br>
              <strong>Expected:</strong> Console logs show Start ‚Üí Dispatch ‚Üí Complete ‚Üí SUCCESS (if permissions granted) or FAILED (if denied). Completion event contains mode: "both", success: boolean, permissions object.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Completion listener registered before dispatch</li>
                <li>‚òê Orchestration event dispatched correctly</li>
                <li>‚òê Completion event received with detail.success</li>
                <li>‚òê Mode matches "both"</li>
                <li>‚òê Permissions object contains camera and microphone states</li>
                <li>‚òê Listener cleaned up after completion</li>
              </ul>
            </td>
            <td>
              <code class="small">
                window.addEventListener('CamMic:Test:WaitFlow:Both', function() {<br>
                &nbsp;&nbsp;const onComplete = (ev) => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const detail = ev.detail || {};<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Handle success/failure<br>
                &nbsp;&nbsp;};<br>
                &nbsp;&nbsp;window.addEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both'));<br>
                });<br>
                <br>
                // Trigger: window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Both'));
              </code>
            </td>
          </tr>
          
          <!-- Test Wait Flow: Microphone Only -->
          <tr>
            <td><strong>Microphone Only</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Test Wait Flow - Mic Only'); window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Microphone'));">
                Test Flow
  </button>
            </td>
            <td>
              <strong>How:</strong> Same pattern as Both, but for microphone-only requests. Registers listener, dispatches microphone orchestration, waits for completion.<br><br>
              <strong>Why:</strong> Verifies microphone-only flows work independently. Tests that single-permission requests complete correctly without camera involvement.<br><br>
              <strong>Expected:</strong> Console logs show Start ‚Üí Dispatch ‚Üí Complete ‚Üí SUCCESS (if mic granted) or FAILED. Completion event contains mode: "microphone", success: boolean, permissions object with microphone state.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Completion listener registered before dispatch</li>
                <li>‚òê Microphone orchestration event dispatched</li>
                <li>‚òê Completion event received with detail.success</li>
                <li>‚òê Mode matches "microphone"</li>
                <li>‚òê Only microphone permission checked (not camera)</li>
                <li>‚òê Listener cleaned up after completion</li>
              </ul>
            </td>
            <td>
              <code class="small">
                window.addEventListener('CamMic:Test:WaitFlow:Microphone', function() {<br>
                &nbsp;&nbsp;const onComplete = (ev) => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const detail = ev.detail || {};<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Handle success/failure<br>
                &nbsp;&nbsp;};<br>
                &nbsp;&nbsp;window.addEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Microphone'));<br>
                });<br>
                <br>
                // Trigger: window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Microphone'));
              </code>
            </td>
          </tr>
          
          <!-- Test Wait Flow: Camera Only -->
          <tr>
            <td><strong>Camera Only</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Test Wait Flow - Camera Only'); window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Camera'));">
                Test Flow
  </button>
            </td>
            <td>
              <strong>How:</strong> Same pattern, but for camera-only requests with video preview enabled. Registers listener, dispatches camera orchestration, waits for completion.<br><br>
              <strong>Why:</strong> Verifies camera-only flows work independently with preview enabled. Tests permission requests and video preview activation together.<br><br>
              <strong>Expected:</strong> Console logs show Start ‚Üí Dispatch ‚Üí Complete ‚Üí SUCCESS (if camera granted) or FAILED. Completion event contains mode: "camera", success: boolean, previewEnabled: true, permissions object.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Completion listener registered before dispatch</li>
                <li>‚òê Camera orchestration event dispatched</li>
                <li>‚òê Completion event received with detail.success</li>
                <li>‚òê Mode matches "camera"</li>
                <li>‚òê Video preview enabled (previewEnabled: true)</li>
                <li>‚òê Only camera permission checked (not microphone)</li>
                <li>‚òê Listener cleaned up after completion</li>
              </ul>
            </td>
            <td>
              <code class="small">
                window.addEventListener('CamMic:Test:WaitFlow:Camera', function() {<br>
                &nbsp;&nbsp;const onComplete = (ev) => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const detail = ev.detail || {};<br>
                &nbsp;&nbsp;&nbsp;&nbsp;// Handle success/failure<br>
                &nbsp;&nbsp;};<br>
                &nbsp;&nbsp;window.addEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera'));<br>
                });<br>
                <br>
                // Trigger: window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Camera'));
              </code>
            </td>
          </tr>
          
          <!-- Test Wait Flow: Both (No Preview) -->
          <tr>
            <td><strong>Both (No Preview)</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Test Wait Flow - Both (No Preview)'); window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Both:NoPreview'));">
                Test Flow
  </button>
            </td>
            <td>
              <strong>How:</strong> Same pattern as Both, but with no preview flag. Requests both permissions without starting video preview automatically.<br><br>
              <strong>Why:</strong> Verifies permissions can be requested without automatic video preview. Useful for audio-only calls or when preview should be manually controlled.<br><br>
              <strong>Expected:</strong> Console logs show Start ‚Üí Dispatch ‚Üí Complete ‚Üí SUCCESS (if permissions granted) or FAILED. Completion event contains mode: "both", success: boolean, previewEnabled: false, permissions object.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Completion listener registered before dispatch</li>
                <li>‚òê Both orchestration event dispatched with NoPreview flag</li>
                <li>‚òê Completion event received with detail.success</li>
                <li>‚òê Mode matches "both"</li>
                <li>‚òê Preview disabled (previewEnabled: false)</li>
                <li>‚òê Both camera and microphone permissions checked</li>
                <li>‚òê Video preview not started automatically</li>
                <li>‚òê Listener cleaned up after completion</li>
              </ul>
            </td>
            <td>
              <code class="small">
                window.addEventListener('CamMic:Test:WaitFlow:Both:NoPreview', function() {<br>
                &nbsp;&nbsp;const onComplete = (ev) => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const detail = ev.detail || {};<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if (detail.success && detail.previewEnabled === false) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle success without preview<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;};<br>
                &nbsp;&nbsp;window.addEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both:NoPreview'));<br>
                });<br>
                <br>
                // Trigger: window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Both:NoPreview'));
              </code>
            </td>
          </tr>
          
          <!-- Test Wait Flow: Camera Only (No Preview) -->
          <tr>
            <td><strong>Camera Only (No Preview)</strong></td>
            <td>
              <button class="btn btn-primary btn-sm" onclick="console.log('[HTML] [onclick] Test Wait Flow - Camera Only (No Preview)'); window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Camera:NoPreview'));">
                Test Flow
  </button>
            </td>
            <td>
              <strong>How:</strong> Same pattern as Camera Only, but with no preview flag. Requests camera permission without starting video preview automatically.<br><br>
              <strong>Why:</strong> Verifies camera permissions can be requested without automatic preview. Useful when preview should be manually controlled or for photo capture scenarios without live preview.<br><br>
              <strong>Expected:</strong> Console logs show Start ‚Üí Dispatch ‚Üí Complete ‚Üí SUCCESS (if camera granted) or FAILED. Completion event contains mode: "camera", success: boolean, previewEnabled: false, permissions object.
            </td>
            <td>
              <ul class="list-unstyled mb-0">
                <li>‚òê Completion listener registered before dispatch</li>
                <li>‚òê Camera orchestration event dispatched with NoPreview flag</li>
                <li>‚òê Completion event received with detail.success</li>
                <li>‚òê Mode matches "camera"</li>
                <li>‚òê Preview disabled (previewEnabled: false)</li>
                <li>‚òê Only camera permission checked (not microphone)</li>
                <li>‚òê Video preview not started automatically</li>
                <li>‚òê Listener cleaned up after completion</li>
              </ul>
            </td>
            <td>
              <code class="small">
                window.addEventListener('CamMic:Test:WaitFlow:Camera:NoPreview', function() {<br>
                &nbsp;&nbsp;const onComplete = (ev) => {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;const detail = ev.detail || {};<br>
                &nbsp;&nbsp;&nbsp;&nbsp;if (detail.success && detail.previewEnabled === false) {<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Handle success without preview<br>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                &nbsp;&nbsp;};<br>
                &nbsp;&nbsp;window.addEventListener('CamMic:Orchestrate:Complete', onComplete);<br>
                &nbsp;&nbsp;window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera:NoPreview'));<br>
                });<br>
                <br>
                // Trigger: window.dispatchEvent(new CustomEvent('CamMic:Test:WaitFlow:Camera:NoPreview'));
              </code>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
</div>

<!-- Required DOM Elements -->
<div style="margin: 20px 0;">
  <h2>Status & Controls</h2>

  <!-- Permission Prompt Icons -->
  <div data-cam-mic-element="permission-icons" hidden>
    <div data-cam-mic-element="need-camera" hidden>üì∑ Please allow camera access</div>
    <div data-cam-mic-element="need-microphone" hidden>üé§ Please allow microphone access</div>
  </div>

  <!-- Second Set of Device Selects (Demo Multiple Selects) -->
  <div style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
    <h3>Second Device Selection (Multiple Selects Demo)</h3>
    <p class="text-muted small">This demonstrates that multiple select elements can be wired up and stay synchronized automatically.</p>
    <label>
      Camera:
      <select data-camera-select></select>
    </label>
    <br /><br />
    <label>
      Microphone:
      <select data-microphone-select></select>
    </label>
  </div>

  <!-- Demo Video Preview Elements (Multiple Previews) -->
  <div style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
    <h3>Multiple Video Previews Demo</h3>
    <p class="text-muted small">This demonstrates that multiple video preview elements with data-cam-preview attribute will sync with the master video automatically.</p>
    <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-top: 15px;">
      <div style="border: 2px solid #0d6efd; border-radius: 8px; overflow: hidden; background: #000;">
        <video data-cam-preview autoplay playsinline style="width: 200px; height: 150px; object-fit: cover; display: block;"></video>
        <p style="margin: 5px; font-size: 0.85em; color: #6c757d; text-align: center;">Preview 1</p>
      </div>
      <div style="border: 2px solid #0d6efd; border-radius: 8px; overflow: hidden; background: #000;">
        <video data-cam-preview autoplay playsinline style="width: 200px; height: 150px; object-fit: cover; display: block;"></video>
        <p style="margin: 5px; font-size: 0.85em; color: #6c757d; text-align: center;">Preview 2</p>
      </div>
      <div style="border: 2px solid #0d6efd; border-radius: 8px; overflow: hidden; background: #000;">
        <video data-cam-preview autoplay playsinline style="width: 200px; height: 150px; object-fit: cover; display: block;"></video>
        <p style="margin: 5px; font-size: 0.85em; color: #6c757d; text-align: center;">Preview 3</p>
      </div>
    </div>
  </div>

  <!-- Reload Required Banner -->
  <div data-cam-mic-element="reload-required" hidden style="background: #ffcccc; padding: 10px; border: 1px solid #ff0000;">
    ‚ö†Ô∏è Permission denied. Page will reload shortly.
  </div>
</div>

<!-- Fixed Bottom Status Bar -->
<div class="fixed-bottom-status">
  <div class="status-container">
    <!-- Loader (moved from Status & Controls) -->
    <div data-cam-mic-element="loader" hidden>üîÑ Checking Permissions...</div>
    
    <!-- Waiting (moved from Status & Controls) -->
    <div data-cam-mic-element="waiting" hidden>‚è≥ Waiting...</div>
    
    <!-- Status Wrap (moved from Status & Controls) -->
    <div class="status-section" data-cam-mic-element="status">
      <div data-cam-mic-element="status-item" data-kind="camera">
        <strong>Camera:</strong> <span data-cam-mic-element="status-camera"></span>
      </div>
      <div data-cam-mic-element="status-item" data-kind="microphone">
        <strong>Microphone:</strong> <span data-cam-mic-element="status-microphone"></span>
      </div>
    </div>
    
    <!-- Device Selection (moved from Status & Controls) -->
    <div class="status-section" data-cam-mic-element="device-select">
      <label>Camera:</label>
      <select data-cam-mic-element="video-select"></select>
      <span data-cam-mic-element="selected-camera-label" style="font-size: 0.85em; color: #6c757d;"></span>
      <label style="margin-left: 10px;">Mic:</label>
      <select data-cam-mic-element="audio-select"></select>
      <span data-cam-mic-element="selected-microphone-label" style="font-size: 0.85em; color: #6c757d;"></span>
    </div>
    
    <!-- Video Preview (moved from Status & Controls) -->
    <div class="video-preview-container">
      <video data-cam-mic-element="video-preview" autoplay playsinline></video>
    </div>
  </div>
</div>

<!-- Footer with selects (hidden - source of truth, created automatically if missing) -->
<footer style="margin-top: 40px; padding: 20px; border-top: 1px solid #ccc; display: none;" hidden>
  <label>
    Camera:
    <select data-camera-select hidden></select>
  </label>
  <br />
  <label>
    Microphone:
    <select data-microphone-select hidden></select>
  </label>
</footer>

<!-- Load Cam/Mic handler (contains both Utility and Handler) -->
<script src="./camMicPermissionsUtility.js"></script>
<script src="./camMicPermissionsHandler.js"></script>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>







<!-- Footer selects are managed by CamMicPermissionsHandler._ensureFooterSelects() -->
<!-- They are hidden and serve as source of truth -->

<!-- Test Wait Flow: External flow that waits for orchestration completion -->
<script>
  (function() {
    /**
     * Test Wait Flow for Both (Cam + Mic)
     * 
     * This flow demonstrates the async orchestration pattern where we:
     * 1. Listen for the test wait flow event trigger
     * 2. Set up a completion listener BEFORE dispatching the orchestration
     * 3. Dispatch the orchestration event
     * 4. Wait for the completion event to verify successful permission handling
     * 
     * This pattern ensures we can verify that multiple event dispatches work correctly
     * and that the orchestration completes before proceeding.
     */
    window.addEventListener('CamMic:Test:WaitFlow:Both', function() {
      // Log the start of the test wait flow
      console.log(`[TestWaitFlow] [Both] [Start] {}`);
      
      // Define completion handler that will be called when orchestration finishes
      // This handler is registered BEFORE dispatching the orchestration event
      // to ensure it can capture the completion event
      const onComplete = function(ev) {
        // Remove the event listener to prevent memory leaks
        // This cleanup happens after the completion event is received
        window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);
        // Extract detail object from event, defaulting to empty object if missing
        const detail = ev.detail || {};
        // Log the completion event with all details
        console.log(`[TestWaitFlow] [Both] [Complete] ${JSON.stringify(detail)}`);
        
        // Check if orchestration was successful and mode matches expected value
        // Success indicates both camera and microphone permissions were granted
        if (detail.success && detail.mode === 'both') {
          // Log success message confirming permissions were granted
          // This confirms the wait flow pattern works correctly with multiple dispatches
          console.log(`[TestWaitFlow] [Both] [SUCCESS] Cam/Mic permissions granted! I waited until AFTER cam mic so we can be sure. Multiple dispatches work correctly.`);
        } else {
          // Log warning if orchestration failed or mode doesn't match
          // This helps identify issues with permission requests or mode detection
          console.warn(`[TestWaitFlow] [Both] [FAILED] ${JSON.stringify({ permissions: detail.permissions || {} })}`);
        }
      };
      
      // Register the completion handler to listen for orchestration completion
      // This must be done BEFORE dispatching the orchestration event
      window.addEventListener('CamMic:Orchestrate:Complete', onComplete);
      
      // Dispatch the orchestration event to start the camera + microphone flow
      // This triggers the CamMicPermissionsHandler to request permissions and set up devices
      console.log(`[TestWaitFlow] [Both] [Dispatch] ${JSON.stringify({ event: 'CamMic:Orchestrate:Both' })}`);
      window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both'));
    });

    /**
     * Test Wait Flow for Microphone Only
     * 
     * This flow demonstrates the async orchestration pattern for microphone-only requests.
     * The flow:
     * 1. Listens for the test wait flow event trigger
     * 2. Sets up a completion listener BEFORE dispatching the orchestration
     * 3. Dispatches the microphone-only orchestration event
     * 4. Waits for the completion event to verify successful microphone permission handling
     * 
     * This pattern ensures we can verify microphone-only flows work independently
     * and that the orchestration completes before proceeding.
     */
    window.addEventListener('CamMic:Test:WaitFlow:Microphone', function() {
      // Log the start of the test wait flow
      console.log(`[TestWaitFlow] [Microphone] [Start] {}`);
      
      // Define completion handler that will be called when orchestration finishes
      // This handler is registered BEFORE dispatching the orchestration event
      // to ensure it can capture the completion event
      const onComplete = function(ev) {
        // Remove the event listener to prevent memory leaks
        // This cleanup happens after the completion event is received
        window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);
        // Extract detail object from event, defaulting to empty object if missing
        const detail = ev.detail || {};
        // Log the completion event with all details
        console.log(`[TestWaitFlow] [Microphone] [Complete] ${JSON.stringify(detail)}`);
        
        // Check if orchestration was successful and mode matches expected value
        // Success indicates microphone permissions were granted
        if (detail.success && detail.mode === 'microphone') {
          // Log success message confirming permissions were granted
          // This confirms the wait flow pattern works correctly with multiple dispatches
          console.log(`[TestWaitFlow] [Microphone] [SUCCESS] Mic permissions granted! I waited until AFTER cam mic so we can be sure. Multiple dispatches work correctly.`);
        } else {
          // Log warning if orchestration failed or mode doesn't match
          // This helps identify issues with permission requests or mode detection
          console.warn(`[TestWaitFlow] [Microphone] [FAILED] ${JSON.stringify({ permissions: detail.permissions || {} })}`);
        }
      };
      
      // Register the completion handler to listen for orchestration completion
      // This must be done BEFORE dispatching the orchestration event
      window.addEventListener('CamMic:Orchestrate:Complete', onComplete);
      
      // Dispatch the orchestration event to start the microphone-only flow
      // This triggers the CamMicPermissionsHandler to request microphone permissions and set up devices
      console.log(`[TestWaitFlow] [Microphone] [Dispatch] ${JSON.stringify({ event: 'CamMic:Orchestrate:Microphone' })}`);
      window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Microphone'));
    });

    /**
     * Test Wait Flow for Camera Only
     * 
     * This flow demonstrates the async orchestration pattern for camera-only requests.
     * The flow:
     * 1. Listens for the test wait flow event trigger
     * 2. Sets up a completion listener BEFORE dispatching the orchestration
     * 3. Dispatches the camera-only orchestration event
     * 4. Waits for the completion event to verify successful camera permission handling
     * 
     * This pattern ensures we can verify camera-only flows work independently
     * and that the orchestration completes before proceeding.
     */
    window.addEventListener('CamMic:Test:WaitFlow:Camera', function() {
      // Log the start of the test wait flow
      console.log(`[TestWaitFlow] [Camera] [Start] {}`);
      
      // Define completion handler that will be called when orchestration finishes
      // This handler is registered BEFORE dispatching the orchestration event
      // to ensure it can capture the completion event
      const onComplete = function(ev) {
        // Remove the event listener to prevent memory leaks
        // This cleanup happens after the completion event is received
        window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);
        // Extract detail object from event, defaulting to empty object if missing
        const detail = ev.detail || {};
        // Log the completion event with all details
        console.log(`[TestWaitFlow] [Camera] [Complete] ${JSON.stringify(detail)}`);
        
        // Check if orchestration was successful and mode matches expected value
        // Success indicates camera permissions were granted
        if (detail.success && detail.mode === 'camera') {
          // Log success message confirming permissions were granted
          // This confirms the wait flow pattern works correctly with multiple dispatches
          console.log(`[TestWaitFlow] [Camera] [SUCCESS] Camera permissions granted! I waited until AFTER cam mic so we can be sure. Multiple dispatches work correctly.`);
        } else {
          // Log warning if orchestration failed or mode doesn't match
          // This helps identify issues with permission requests or mode detection
          console.warn(`[TestWaitFlow] [Camera] [FAILED] ${JSON.stringify({ permissions: detail.permissions || {} })}`);
        }
      };
      
      // Register the completion handler to listen for orchestration completion
      // This must be done BEFORE dispatching the orchestration event
      window.addEventListener('CamMic:Orchestrate:Complete', onComplete);
      
      // Dispatch the orchestration event to start the camera-only flow
      // This triggers the CamMicPermissionsHandler to request camera permissions and set up devices
      console.log(`[TestWaitFlow] [Camera] [Dispatch] ${JSON.stringify({ event: 'CamMic:Orchestrate:Camera' })}`);
      window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera'));
    });

    /**
     * Test Wait Flow for Both (Cam + Mic) - No Preview
     * 
     * This flow demonstrates the async orchestration pattern for both camera and microphone
     * requests without enabling video preview. The flow:
     * 1. Listens for the test wait flow event trigger
     * 2. Sets up a completion listener BEFORE dispatching the orchestration
     * 3. Dispatches the both orchestration event with no preview flag
     * 4. Waits for the completion event to verify successful permission handling without preview
     * 
     * This pattern ensures we can verify that permissions can be requested without
     * automatically starting video preview, which is useful for audio-only calls or
     * when preview should be manually controlled.
     */
    window.addEventListener('CamMic:Test:WaitFlow:Both:NoPreview', function() {
      // Log the start of the test wait flow
      console.log(`[TestWaitFlow] [Both:NoPreview] [Start] {}`);
      
      // Define completion handler that will be called when orchestration finishes
      // This handler is registered BEFORE dispatching the orchestration event
      // to ensure it can capture the completion event
      const onComplete = function(ev) {
        // Remove the event listener to prevent memory leaks
        // This cleanup happens after the completion event is received
        window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);
        // Extract detail object from event, defaulting to empty object if missing
        const detail = ev.detail || {};
        // Log the completion event with all details
        console.log(`[TestWaitFlow] [Both:NoPreview] [Complete] ${JSON.stringify(detail)}`);
        
        // Check if orchestration was successful, mode matches expected value, and preview is disabled
        // Success indicates both camera and microphone permissions were granted without preview
        if (detail.success && detail.mode === 'both' && detail.previewEnabled === false) {
          // Log success message confirming permissions were granted and preview is disabled
          // This confirms the wait flow pattern works correctly with no preview mode
          console.log(`[TestWaitFlow] [Both:NoPreview] [SUCCESS] Cam/Mic permissions granted! Preview disabled. I waited until AFTER cam mic so we can be sure. Multiple dispatches work correctly.`);
        } else {
          // Log warning if orchestration failed, mode doesn't match, or preview is enabled
          // This helps identify issues with permission requests, mode detection, or preview control
          console.warn(`[TestWaitFlow] [Both:NoPreview] [FAILED] ${JSON.stringify({ permissions: detail.permissions || {}, previewEnabled: detail.previewEnabled })}`);
        }
      };
      
      // Register the completion handler to listen for orchestration completion
      // This must be done BEFORE dispatching the orchestration event
      window.addEventListener('CamMic:Orchestrate:Complete', onComplete);
      
      // Dispatch the orchestration event to start the camera + microphone flow without preview
      // This triggers the CamMicPermissionsHandler to request permissions and set up devices
      // without automatically enabling video preview
      console.log(`[TestWaitFlow] [Both:NoPreview] [Dispatch] ${JSON.stringify({ event: 'CamMic:Orchestrate:Both:NoPreview' })}`);
      window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Both:NoPreview'));
    });

    /**
     * Test Wait Flow for Camera Only - No Preview
     * 
     * This flow demonstrates the async orchestration pattern for camera-only requests
     * without enabling video preview. The flow:
     * 1. Listens for the test wait flow event trigger
     * 2. Sets up a completion listener BEFORE dispatching the orchestration
     * 3. Dispatches the camera-only orchestration event with no preview flag
     * 4. Waits for the completion event to verify successful camera permission handling without preview
     * 
     * This pattern ensures we can verify that camera permissions can be requested without
     * automatically starting video preview, which is useful when preview should be manually controlled
     * or when camera is needed for other purposes (like photo capture) without live preview.
     */
    window.addEventListener('CamMic:Test:WaitFlow:Camera:NoPreview', function() {
      // Log the start of the test wait flow
      console.log(`[TestWaitFlow] [Camera:NoPreview] [Start] {}`);
      
      // Define completion handler that will be called when orchestration finishes
      // This handler is registered BEFORE dispatching the orchestration event
      // to ensure it can capture the completion event
      const onComplete = function(ev) {
        // Remove the event listener to prevent memory leaks
        // This cleanup happens after the completion event is received
        window.removeEventListener('CamMic:Orchestrate:Complete', onComplete);
        // Extract detail object from event, defaulting to empty object if missing
        const detail = ev.detail || {};
        // Log the completion event with all details
        console.log(`[TestWaitFlow] [Camera:NoPreview] [Complete] ${JSON.stringify(detail)}`);
        
        // Check if orchestration was successful, mode matches expected value, and preview is disabled
        // Success indicates camera permissions were granted without preview
        if (detail.success && detail.mode === 'camera' && detail.previewEnabled === false) {
          // Log success message confirming permissions were granted and preview is disabled
          // This confirms the wait flow pattern works correctly with no preview mode
          console.log(`[TestWaitFlow] [Camera:NoPreview] [SUCCESS] Camera permissions granted! Preview disabled. I waited until AFTER cam mic so we can be sure. Multiple dispatches work correctly.`);
        } else {
          // Log warning if orchestration failed, mode doesn't match, or preview is enabled
          // This helps identify issues with permission requests, mode detection, or preview control
          console.warn(`[TestWaitFlow] [Camera:NoPreview] [FAILED] ${JSON.stringify({ permissions: detail.permissions || {}, previewEnabled: detail.previewEnabled })}`);
        }
      };
      
      // Register the completion handler to listen for orchestration completion
      // This must be done BEFORE dispatching the orchestration event
      window.addEventListener('CamMic:Orchestrate:Complete', onComplete);
      
      // Dispatch the orchestration event to start the camera-only flow without preview
      // This triggers the CamMicPermissionsHandler to request camera permissions and set up devices
      // without automatically enabling video preview
      console.log(`[TestWaitFlow] [Camera:NoPreview] [Dispatch] ${JSON.stringify({ event: 'CamMic:Orchestrate:Camera:NoPreview' })}`);
      window.dispatchEvent(new CustomEvent('CamMic:Orchestrate:Camera:NoPreview'));
    });
    
    // URL Parameter State Auto-Select (Debug Only)
    // Check for ?state=caller:callWaiting in URL and auto-select from debug dropdown
    (function() {
      const urlParams = new URLSearchParams(window.location.search);
      const stateParam = urlParams.get('state');
      if (stateParam) {
        console.log('[Debug] URL state parameter detected:', stateParam);
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            const stateSelect = document.getElementById('stateSelect');
            if (stateSelect) {
              stateSelect.value = stateParam;
              console.log('[Debug] Auto-selected state from URL:', stateParam);
              // Trigger the change event to dispatch the state
              stateSelect.dispatchEvent(new Event('change'));
            }
          });
        } else {
          // DOM already loaded
          const stateSelect = document.getElementById('stateSelect');
          if (stateSelect) {
            stateSelect.value = stateParam;
            console.log('[Debug] Auto-selected state from URL:', stateParam);
            // Trigger the change event to dispatch the state
            stateSelect.dispatchEvent(new Event('change'));
          }
        }
      }
    })();
  })();
</script>
</div> <!-- End container -->
</body>
</body>

</html>